patch that replaces alloca() usage in Tremor.
I did NOT need and did NOT use this.  I am
keeping this here only for future reference.

--- codebook.c~	2010-10-18 12:54:48.000000000 +0300
+++ codebook.c	2011-07-19 01:04:02.000000000 +0300
@@ -246,15 +246,19 @@ long vorbis_book_decodevs_add(codebook *
 			      oggpack_buffer *b,int n,int point){
   if(book->used_entries>0){  
     int step=n/book->dim;
-    long *entry = (long *)alloca(sizeof(*entry)*step);
-    ogg_int32_t **t = (ogg_int32_t **)alloca(sizeof(*t)*step);
+    long *entry = (long *)_ogg_alloca(sizeof(*entry)*step);
+    ogg_int32_t **t = (ogg_int32_t **)_ogg_alloca(sizeof(*t)*step);
     int i,j,o;
     int shift=point-book->binarypoint;
     
     if(shift>=0){
       for (i = 0; i < step; i++) {
 	entry[i]=decode_packed_entry_number(book,b);
-	if(entry[i]==-1)return(-1);
+	if(entry[i]==-1){
+	  _ogg_stackfree(t);
+	  _ogg_stackfree(entry);
+	  return(-1);
+	}
 	t[i] = book->valuelist+entry[i]*book->dim;
       }
       for(i=0,o=0;i<book->dim;i++,o+=step)
@@ -263,13 +267,19 @@ long vorbis_book_decodevs_add(codebook *
     }else{
       for (i = 0; i < step; i++) {
 	entry[i]=decode_packed_entry_number(book,b);
-	if(entry[i]==-1)return(-1);
+	if(entry[i]==-1){
+	  _ogg_stackfree(t);
+	  _ogg_stackfree(entry);
+	  return(-1);
+	}
 	t[i] = book->valuelist+entry[i]*book->dim;
       }
       for(i=0,o=0;i<book->dim;i++,o+=step)
 	for (j=0;j<step;j++)
 	  a[o+j]+=t[j][i]<<-shift;
     }
+  _ogg_stackfree(t);
+  _ogg_stackfree(entry);
   }
   return(0);
 }
--- floor0.c~	2010-10-18 14:30:23.000000000 +0300
+++ floor0.c	2011-07-19 00:44:54.000000000 +0300
@@ -145,7 +145,7 @@ void vorbis_lsp_to_curve(ogg_int32_t *cu
   int i;
   int ampoffseti=ampoffset*4096;
   int ampi=amp;
-  ogg_int32_t *ilsp=(ogg_int32_t *)alloca(m*sizeof(*ilsp));
+  ogg_int32_t *ilsp=(ogg_int32_t *)_ogg_alloca(m*sizeof(*ilsp));
   /* lsp is in 8.24, range 0 to PI; coslook wants it in .16 0 to 1*/
   for(i=0;i<m;i++){
 #ifndef _LOW_ACCURACY_
@@ -156,6 +156,7 @@ void vorbis_lsp_to_curve(ogg_int32_t *cu
 
     /* safeguard against a malicious stream */
     if(val<0 || (val>>COS_LOOKUP_I_SHIFT)>=COS_LOOKUP_I_SZ){
+      _ogg_stackfree(ilsp);
       memset(curve,0,sizeof(*curve)*n);
       return;
     }
@@ -284,6 +285,7 @@ void vorbis_lsp_to_curve(ogg_int32_t *cu
     curve[i]= MULT31_SHIFT15(curve[i],amp);
     while(map[++i]==k) curve[i]= MULT31_SHIFT15(curve[i],amp);
   }
+  _ogg_stackfree(ilsp);
 }
 
 /*************** vorbis decode glue ************/
--- info.c~	2010-10-14 04:33:46.000000000 +0300
+++ info.c	2011-07-19 01:06:39.000000000 +0300
@@ -65,19 +65,23 @@ char *vorbis_comment_query(vorbis_commen
   for(i=0;i<vc->comments;i++){
     if(!tagcompare(vc->user_comments[i], fulltag, taglen)){
       if(count == found)
+      {
 	/* We return a pointer to the data, not a copy */
+	_ogg_stackfree(fulltag);
       	return vc->user_comments[i] + taglen;
+      }
       else
 	found++;
     }
   }
+  _ogg_stackfree(fulltag);
   return NULL; /* didn't find anything */
 }
 
 int vorbis_comment_query_count(vorbis_comment *vc, char *tag){
   int i,count=0;
   int taglen = strlen(tag)+1; /* +1 for the = we append */
-  char *fulltag = (char *)alloca(taglen+1);
+  char *fulltag = (char *)_ogg_alloca(taglen+1);
   strcpy(fulltag,tag);
   strcat(fulltag, "=");
 
@@ -86,6 +90,7 @@ int vorbis_comment_query_count(vorbis_co
       count++;
   }
 
+  _ogg_stackfree(fulltag);
   return count;
 }
 
--- mapping0.c~	2010-10-14 04:05:50.000000000 +0300
+++ mapping0.c	2011-07-19 00:53:14.000000000 +0300
@@ -194,11 +194,11 @@ static int mapping0_inverse(vorbis_block
   int                   i,j;
   long                  n=vb->pcmend=ci->blocksizes[vb->W];
 
-  ogg_int32_t **pcmbundle=(ogg_int32_t **)alloca(sizeof(*pcmbundle)*vi->channels);
-  int    *zerobundle=(int *)alloca(sizeof(*zerobundle)*vi->channels);
+  ogg_int32_t **pcmbundle=(ogg_int32_t **)_ogg_alloca(sizeof(*pcmbundle)*vi->channels);
+  int    *zerobundle=(int *)_ogg_alloca(sizeof(*zerobundle)*vi->channels);
   
-  int   *nonzero  =(int *)alloca(sizeof(*nonzero)*vi->channels);
-  void **floormemo=(void **)alloca(sizeof(*floormemo)*vi->channels);
+  int   *nonzero  =(int *)_ogg_alloca(sizeof(*nonzero)*vi->channels);
+  void **floormemo=(void **)_ogg_alloca(sizeof(*floormemo)*vi->channels);
   
   /* time domain information decode (note that applying the
      information would have to happen later; we'll probably add a
@@ -315,6 +315,10 @@ static int mapping0_inverse(vorbis_block
 
   seq+=vi->channels;
   /* all done! */
+  _ogg_stackfree(pcmbundle);
+  _ogg_stackfree(zerobundle);
+  _ogg_stackfree(nonzero);
+  _ogg_stackfree(floormemo);
   return(0);
 }
 
--- res012.c~	2010-10-18 12:53:27.000000000 +0300
+++ res012.c	2011-07-19 00:49:56.000000000 +0300
@@ -226,7 +226,7 @@ static int _01inverse(vorbis_block *vb,v
   if(n>0){
     int partvals=n/samples_per_partition;
     int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
-    int ***partword=(int ***)alloca(ch*sizeof(*partword));
+    int ***partword=(int ***)_ogg_alloca(ch*sizeof(*partword));
     
     for(j=0;j<ch;j++)
       partword[j]=(int **)_vorbis_block_alloc(vb,partwords*sizeof(*partword[j]));
@@ -260,9 +260,10 @@ static int _01inverse(vorbis_block *vb,v
 	  }
       } 
     }
-  }
  errout:
  eopbreak:
+  _ogg_stackfree(partword);
+  }
   return(0);
 }
 
--- sharedbook.c~	2010-10-14 04:33:46.000000000 +0300
+++ sharedbook.c	2011-07-19 00:39:04.000000000 +0300
@@ -354,10 +354,11 @@ int vorbis_book_init_decode(codebook *c,
        by sorted bitreversed codeword to allow treeless decode. */
     
     /* perform sort */
-    ogg_uint32_t *codes=_make_words(s->lengthlist,s->entries,c->used_entries);
-    ogg_uint32_t **codep=(ogg_uint32_t **)alloca(sizeof(*codep)*n);
+    ogg_uint32_t *codes, **codep;
     
+    codes=_make_words(s->lengthlist,s->entries,c->used_entries);
     if(codes==NULL)goto err_out;
+    codep=(ogg_uint32_t **)_ogg_alloca(sizeof(*codep)*n);
 
     for(i=0;i<n;i++){
       codes[i]=bitreverse(codes[i]);
@@ -366,7 +367,7 @@ int vorbis_book_init_decode(codebook *c,
 
     qsort(codep,n,sizeof(*codep),sort32a);
 
-    sortindex=(int *)alloca(n*sizeof(*sortindex));
+    sortindex=(int *)_ogg_alloca(n*sizeof(*sortindex));
     c->codelist=(ogg_uint32_t *)_ogg_malloc(n*sizeof(*c->codelist));
     /* the index is a reverse index */
     for(i=0;i<n;i++){
@@ -378,7 +379,7 @@ int vorbis_book_init_decode(codebook *c,
       c->codelist[sortindex[i]]=codes[i];
     _ogg_free(codes);
     
-    
+    _ogg_stackfree(codep);
     
     c->valuelist=_book_unquantize(s,n,sortindex,&c->binarypoint);
     c->dec_index=(int *)_ogg_malloc(n*sizeof(*c->dec_index));
@@ -392,6 +393,8 @@ int vorbis_book_init_decode(codebook *c,
       if(s->lengthlist[i]>0)
 	c->dec_codelengths[sortindex[n++]]=s->lengthlist[i];
     
+    _ogg_stackfree(sortindex);
+
     c->dec_firsttablen=_ilog(c->used_entries)-4; /* this is magic */
     if(c->dec_firsttablen<5)c->dec_firsttablen=5;
     if(c->dec_firsttablen>8)c->dec_firsttablen=8;

