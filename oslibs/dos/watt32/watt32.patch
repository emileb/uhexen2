diff -urp watt_src.orig/inc/sys/cdefs.h watt_src/inc/sys/cdefs.h
--- watt_src.orig/inc/sys/cdefs.h	2005-12-30 00:14:10.000000000 +0200
+++ watt_src/inc/sys/cdefs.h	2015-05-01 05:55:00.000000000 +0300
@@ -44,9 +44,8 @@
 #ifndef __SYS_CDEFS_H
 #define __SYS_CDEFS_H
 
-#if defined(__DJGPP__) && !defined(djgpp_cdefs_incl)
-  #include "/dev/env/DJDIR/include/sys/cdefs.h"
-  #define djgpp_cdefs_incl
+#if defined(__DJGPP__)
+  #include_next <sys/cdefs.h>
 #endif
 
 #ifdef __cplusplus
@@ -188,6 +187,16 @@ struct mbuf {
   #endif
 #endif
 
+#if defined(__GNUC__)  /* from djgpp-2.04 sys/cdefs.h : */
+/* Ensure that always traditional GNU extern inline semantics are used
+   (aka -fgnu89-inline) even if ISO C99 semantics have been specified.  */
+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)
+# define _W32_EXTERN_INLINE  extern __inline__ __attribute__ ((__gnu_inline__))
+#else
+# define _W32_EXTERN_INLINE  extern __inline__
+#endif
+#endif /* _W32_EXTERN_INLINE */
+
 /*
  * Delete pseudo-keywords wherever they are not available or needed.
  * This seems to break MingW in mysterious ways, so leave it,
diff -urp watt_src.orig/inc/sys/packoff.h watt_src/inc/sys/packoff.h
--- watt_src.orig/inc/sys/packoff.h	2006-01-15 02:33:18.000000000 +0200
+++ watt_src/inc/sys/packoff.h	2015-05-15 05:55:00.000000000 +0300
@@ -57,6 +57,8 @@ Revision History:
   #elif defined(__WATCOMC__) && (__WATCOMC__ >= 1000)
     #pragma pack(__pop);
   #elif (defined(_MSC_VER) && (_MSC_VER > 800)) || \
+        (defined(__GNUC__) && ((__GNUC__ > 2) || \
+              (__GNUC__ == 2 && __GNUC_MINOR__ > 95))) || \
         (defined(__BORLANDC__) && (__BORLANDC__ >= 0x500)) || \
          defined(__POCC__) || defined(__LCC__)
     #pragma pack(pop)
diff -urp watt_src.orig/inc/sys/packon.h watt_src/inc/sys/packon.h
--- watt_src.orig/inc/sys/packon.h	2006-01-15 02:33:12.000000000 +0200
+++ watt_src/inc/sys/packon.h	2015-05-15 05:55:00.000000000 +0300
@@ -53,6 +53,8 @@ Revision History:
   #elif defined(__WATCOMC__) && (__WATCOMC__ >= 1000)
     #pragma pack(__push,1);
   #elif (defined(_MSC_VER) && (_MSC_VER > 800)) || \
+        (defined(__GNUC__) && ((__GNUC__ > 2) || \
+              (__GNUC__ == 2 && __GNUC_MINOR__ > 95))) || \
         (defined(__BORLANDC__) && (__BORLANDC__ >= 0x500)) || \
          defined(__POCC__) || defined(__LCC__)
     #pragma pack(push,1)
Only in watt_src/inc: djstdint
diff -urp watt_src.orig/inc/sys/djgpp.err watt_src/inc/sys/djgpp.err
--- watt_src.orig/inc/sys/djgpp.err	2005-12-29 22:10:20.000000000 +0200
+++ watt_src/inc/sys/djgpp.err	2015-06-28 10:55:28.000000000 +0300
@@ -2,18 +2,17 @@
 #define __SYS_WERRNO_ERR
 
 /*
- * THIS FILE WAS GENERATED BY e:/net/watt/util/dj_err.exe. DO NOT EDIT.
+ * THIS FILE WAS GENERATED BY c:/net/watt/util/dj_err.exe. DO NOT EDIT.
  *
- * Watt-32 errnos are after vendor's errnos (1 - 38)
+ * Watt-32 errnos are after vendor's errnos (1 - 41)
  */
 
 #ifndef __DJGPP__
 #error This file is only for use by "__DJGPP__"
 #endif
 
-#define ERRNO_VENDOR_VERSION  "2.03"
+#define ERRNO_VENDOR_VERSION  "2.05"
 
-#define EWOULDBLOCK       39
 #define EDOM              1
 #define ERANGE            2
 #define E2BIG             3
@@ -52,62 +51,63 @@
 #define ESRCH             36
 #define EXDEV             37
 #define ENMFILE           38
-#define EINPROGRESS       40
-#define EALREADY          41
-#define ENOTSOCK          42
-#define EDESTADDRREQ      43
-#define EMSGSIZE          44
-#define EPROTOTYPE        45
-#define ENOPROTOOPT       46
-#define EPROTONOSUPPORT   47
-#define ESOCKTNOSUPPORT   48
-#define EOPNOTSUPP        49
-#define EPFNOSUPPORT      50
-#define EAFNOSUPPORT      51
-#define EADDRINUSE        52
-#define EADDRNOTAVAIL     53
-#define ENETDOWN          54
-#define ENETUNREACH       55
-#define ENETRESET         56
-#define ECONNABORTED      57
-#define ECONNRESET        58
-#define ENOBUFS           59
-#define EISCONN           60
-#define ENOTCONN          61
-#define ESHUTDOWN         62
-#define ETIMEDOUT         63
-#define ECONNREFUSED      64
-#define EHOSTDOWN         65
-#define EHOSTUNREACH      66
-#define ESTALE            67
-#define EREMOTE           68
-#define EBADRPC           69
-#define ERPCMISMATCH      70
-#define EPROGUNAVAIL      71
-#define EPROGMISMATCH     72
-#define EPROCUNAVAIL      73
-#define EILSEQ            74
-#define EINVFNC           75
-#define ENOPATH           76
-#define ECONTR            77
-#define EINVMEM           78
-#define EINVENV           79
-#define EINVFMT           80
-#define EINVACC           81
-#define EINVDAT           82
-#define EDEADLOCK         83
-#define ECURDIR           84
-#define ENOTSAM           85
-#define ETXTBSY           86
-#define ENOTBLK           87
-#define EUCLEAN           88
-#define ETOOMANYREFS      89
-#define ELOOP             90
-#define EPROCLIM          91
-#define EUSERS            92
-#define EDQUOT            93
-#define EVDBAD            94
-#define ENORMTWD          95
-#define EOVERFLOW         96
+#define ELOOP             39
+#define EOVERFLOW         40
+#define EILSEQ            41
+#define EWOULDBLOCK       42
+#define EINPROGRESS       43
+#define EALREADY          44
+#define ENOTSOCK          45
+#define EDESTADDRREQ      46
+#define EMSGSIZE          47
+#define EPROTOTYPE        48
+#define ENOPROTOOPT       49
+#define EPROTONOSUPPORT   50
+#define ESOCKTNOSUPPORT   51
+#define EOPNOTSUPP        52
+#define EPFNOSUPPORT      53
+#define EAFNOSUPPORT      54
+#define EADDRINUSE        55
+#define EADDRNOTAVAIL     56
+#define ENETDOWN          57
+#define ENETUNREACH       58
+#define ENETRESET         59
+#define ECONNABORTED      60
+#define ECONNRESET        61
+#define ENOBUFS           62
+#define EISCONN           63
+#define ENOTCONN          64
+#define ESHUTDOWN         65
+#define ETIMEDOUT         66
+#define ECONNREFUSED      67
+#define EHOSTDOWN         68
+#define EHOSTUNREACH      69
+#define ESTALE            70
+#define EREMOTE           71
+#define EBADRPC           72
+#define ERPCMISMATCH      73
+#define EPROGUNAVAIL      74
+#define EPROGMISMATCH     75
+#define EPROCUNAVAIL      76
+#define EINVFNC           77
+#define ENOPATH           78
+#define ECONTR            79
+#define EINVMEM           80
+#define EINVENV           81
+#define EINVFMT           82
+#define EINVACC           83
+#define EINVDAT           84
+#define EDEADLOCK         85
+#define ECURDIR           86
+#define ENOTSAM           87
+#define ETXTBSY           88
+#define ENOTBLK           89
+#define EUCLEAN           90
+#define ETOOMANYREFS      91
+#define EPROCLIM          92
+#define EUSERS            93
+#define EDQUOT            94
+#define EVDBAD            95
+#define ENORMTWD          96
 
 #endif /* __SYS_WERRNO_ERR */
diff -urp watt_src.orig/inc/sys/swap.h watt_src/inc/sys/swap.h
--- watt_src.orig/inc/sys/swap.h	2005-12-30 00:02:44.000000000 +0200
+++ watt_src/inc/sys/swap.h	2015-05-01 05:55:00.000000000 +0300
@@ -58,7 +58,7 @@ __BEGIN_DECLS
   /*
    * Ripped (and adapted) from <linux/include/asm-386/byteorder.h>
    */
-  /*@unused@*/ extern __inline__ unsigned long __ntohl (unsigned long x)
+  /*@unused@*/ _W32_EXTERN_INLINE unsigned long __ntohl (unsigned long x)
   {
     __asm__ __volatile (
              "xchgb %b0, %h0\n\t"   /* swap lower bytes  */
@@ -68,7 +68,7 @@ __BEGIN_DECLS
     return (x);
   }
 
-  /*@unused@*/ extern __inline__ unsigned short __ntohs (unsigned short x)
+  /*@unused@*/ _W32_EXTERN_INLINE unsigned short __ntohs (unsigned short x)
   {
     __asm__ __volatile__ (
               "xchgb %b0, %h0"       /* swap bytes */
diff -urp watt_src.orig/inc/sys/wtypes.h watt_src/inc/sys/wtypes.h
--- watt_src.orig/inc/sys/wtypes.h	2005-12-19 03:55:48.000000000 +0200
+++ watt_src/inc/sys/wtypes.h	2011-11-28 20:15:35.000000000 +0200
@@ -68,6 +68,12 @@
   #define HAVE_STDINT_H
   #include <stdint.h>   /* doesn't define 'u_char' etc. */
 #endif
+#if defined(__DJGPP__) &&	\
+    (!defined(__DJGPP_MINOR__) || __DJGPP_MINOR__ < 4)
+  #undef  HAVE_STDINT_H
+  #define HAVE_STDINT_H
+  #include "djstdint/stdint.h"
+#endif
 
 
 #if !defined(HAVE_U_INT64_T) && !defined(u_int64_t)
diff -urp watt_src.orig/inc/tcp.h watt_src/inc/tcp.h
--- watt_src.orig/inc/tcp.h	2006-01-09 10:34:26.000000000 +0200
+++ watt_src/inc/tcp.h	2014-05-20 20:02:00.000000000 +0300
@@ -49,9 +49,6 @@
 
 #ifdef __cplusplus
   extern "C" {
-  #if 0  /* keep Emacs's auto-indent happy */
-  }
-  #endif
 #endif
 
 W32_DATA const char *wattcpCopyright;  /* "See COPYRIGHT.H for details" */
@@ -87,6 +84,7 @@ W32_FUNC const char *wattcpCapabilities 
 /*
  * Old compatibility
  */
+#ifndef WATT32_NO_OLDIES
 #ifndef byte
 #define byte  unsigned char
 #endif
@@ -102,6 +100,7 @@ W32_FUNC const char *wattcpCapabilities 
 #ifndef longword
 #define longword unsigned long
 #endif
+#endif
 
 /*
  * Basic typedefs
diff -urp watt_src.orig/src/btree.c watt_src/src/btree.c
--- watt_src.orig/src/btree.c	2003-07-16 22:34:10.000000000 +0300
+++ watt_src/src/btree.c	2014-05-20 20:02:00.000000000 +0300
@@ -213,7 +213,7 @@ typedef struct {
         int  id;
       } record;
 
-record rec;
+static record rec;
 
 
 void prompt (const char *verb)
diff -urp watt_src.orig/src/config.h watt_src/src/config.h
--- watt_src.orig/src/config.h	2006-01-15 02:07:18.000000000 +0200
+++ watt_src/src/config.h	2016-06-25 23:55:00.000000000 +0300
@@ -100,20 +100,20 @@
  * Else, for all targets define these options:
  */
 #if !defined(OPT_DEFINED)
-  #define USE_DEBUG
-  #define USE_BOOTP
+/*#define USE_DEBUG */
+/*#define USE_BOOTP */
   #define USE_DHCP
-  #define USE_LANGUAGE
+/*#define USE_LANGUAGE */
   #define USE_FRAGMENTS
-  #define USE_STATISTICS
-  #define USE_BIND
+/*#define USE_STATISTICS*/
+/*#define USE_BIND */
   #define USE_BSD_API
-  #define USE_BSD_FATAL
+/*#define USE_BSD_FATAL */
   #define USE_LOOPBACK
   #define USE_BUFFERED_IO
-  #define USE_TFTP
-  #define USE_MULTICAST
-  #define USE_PPPOE
+/*#define USE_TFTP */
+/*#define USE_MULTICAST*/
+/*#define USE_PPPOE */		/* no longer enabled by default in 2.2.11: G.V. says it never worked. */
   #define OPT_DEFINED
 #endif
 
@@ -122,19 +122,19 @@
  */
 #if defined(__DJGPP__) || defined(__HIGHC__) || defined(WATCOM386) || \
     defined(DMC386) || defined(WIN32)
-  #define USE_ECHO_DISC
-  #define USE_RARP
-  #define USE_IPV6
-  #define USE_IDNA
-  #define USE_TCP_MD5
-  #define USE_GZIP_COMPR
-  #define USE_DYNIP_CLI
+/*#define USE_ECHO_DISC */
+/*#define USE_RARP */
+/*#define USE_IPV6 */
+/*#define USE_IDNA */
+/*#define USE_TCP_MD5*/
+/*#define USE_GZIP_COMPR */
+/*#define USE_DYNIP_CLI */
 #endif
 
 #if defined(__DJGPP__)
-  #define USE_FSEXT
-  #define USE_RS232_DBG
-  #define USE_FORTIFY
+/*#define USE_FSEXT */
+/*#define USE_RS232_DBG*/
+/*#define USE_FORTIFY */
 /*#define USE_SECURE_ARP */
 #endif
 
@@ -143,7 +143,7 @@
 #endif
 
 #if (DOSX) && defined(HAVE_UINT64)
-  #define USE_PROFILER
+/*#define USE_PROFILER */
 #endif
 
 #if defined(__POCC__)
Only in watt_src/src: config.h.bak
Only in watt_src/src: config.h.dbg
Only in watt_src/src: config.h.rel
diff -urp watt_src.orig/src/cpumodel.asm watt_src/src/cpumodel.asm
--- watt_src.orig/src/cpumodel.asm	2005-12-29 23:10:20.000000000 +0200
+++ watt_src/src/cpumodel.asm	2008-08-31 11:36:44.000000000 +0300
@@ -4,15 +4,15 @@
 ;  It is based on linux cpu detection code.
 ;
 ;  Intel also provides public similar code in the book
-;  called :
+;  called:
 ;
 ;  Pentium Processor Family
 ;      Developer Family
-;  Volume  3 : Architecture and Programming Manual
+;  Volume 3: Architecture and Programming Manual
 ;
 ;  At the following place :
 ;
-;  Chapter 5 : Feature determination
+;  Chapter 5:  Feature determination
 ;  Chapter 25: CPUID instruction
 ;
 ;  COPYRIGHT (c) 1998 valette@crf.canon.fr
@@ -29,7 +29,7 @@
 
 PAGE 66, 132
 
-ifdef DOSX  ; only for 32-bit target (including WIN32)
+ifdef DOSX  ; only for 32-bit targets (including WIN32)
 
 ;
 ; All '__w32_' and '_x86' symbols are only needed for Borland and
@@ -61,12 +61,12 @@ PUBLIC _w32_SelWriteable, __w32_SelWrite
 ifdef ??version   ; Turbo Assembler
   .486p
   .487
-else
+else              ; MASM, ML or WASM
   .586p
   .387
 endif
 
-ifdef X32VM       ; FlashTek's X32 isn't flat-model, but SMALL
+ifdef X32VM       ; FlashTek's X32 isn't FLAT model, but SMALL
   .MODEL SMALL,C
 else
   .MODEL FLAT,C
@@ -153,7 +153,6 @@ __w32_CheckCpuType:
     xor  eax, ecx                   ; check if ID bit changed
     and  eax, EFLAGS_ID
 
-    ;
     ; If we are on a straight 486DX, SX, or 487SX we can't
     ; change it. OTOH 6x86MXs and MIIs check OK.
     ; Also if we are on a Cyrix 6x86(L)
@@ -175,9 +174,8 @@ isnew:
 
     mov  cl, al                     ; save reg for future use
 
-    and  ah, 0Fh                    ; mask processor family
+    and  ah, 0Fh                    ; mask processor family (bit 8-11)
     mov  x86_type, ah               ; put result in x86_type (0..15)
-    and  x86_type, 7
 
     and  al, 0F0h                   ; get model
     shr  al, 4
@@ -226,7 +224,7 @@ is486x:
     div bl
     lahf
     cmp ah, 2
-    jne ncyrix
+    jne is386
 
     ;
     ; N.B. The pattern of accesses to 0x22 and 0x23 is *essential*
@@ -259,10 +257,15 @@ getCx86 MACRO reg
     mov bx, ax               ; to enable CPUID execution
     setCx86 0E8h, bx
 
-    getCx86 0FEh             ; DIR0 : let's check this is a 6x86(L)
-    and ax, 0F0h             ; should be 3xh
-    cmp ax, 30h
-    jne n6x86
+; Must check cpu id regs here and not after trying to set CCR3
+; to avoid failure when testing SG Microelectronic STPCs, which
+; lock up if you try to enable cpuid execution
+
+    getCx86 0FEh             ; DIR0 : let's check if this is a 6x86(L)
+    and  ax, 0F0h            ; should be 3xh
+    cmp  ax, 30h             ; STPCs return 0x80, 0x1a, 0x1b or 0x1f
+    jne  is386
+
     getCx86 0E9h             ; CCR5 : we reset the SLOP bit
     and ax, 0FDh             ; so that udelay calculation
     mov bx, ax               ; is correct on 6x86(L) CPUs
@@ -272,15 +275,6 @@ getCx86 MACRO reg
     sti
     jmp isnew                ; We enabled CPUID now
 
-n6x86:
-    setCx86 0C3h, cx         ; Restore old CCR3
-    sti
-
-ncyrix:
-    popfd                    ; restore original EFLAGS
-    call check_x87
-    jmp  end_CheckCpuType
-
 is386:
     popfd                    ; restore original EFLAGS
     call check_x87
@@ -404,7 +398,7 @@ __w32_MY_SS:
 ;
 ; DWORD cdecl Get_CR4 (void);
 ;
-; Is virtualised under Win32 (always returns 0), hence of no use.
+; This is virtualised under Win32 (always returns 0), hence of no use.
 ; Don't call this function w/o checking for a true Pentium first
 ; (see RDTSC_enabled() in misc.c). Returns 0 if CPL != 0.
 ;
diff -urp watt_src.orig/src/cpumodel.S watt_src/src/cpumodel.S
--- watt_src.orig/src/cpumodel.S	2005-12-29 23:10:34.000000000 +0200
+++ watt_src/src/cpumodel.S	2007-01-23 11:24:18.000000000 +0200
@@ -39,8 +39,8 @@ DATA (x86_vendor_id,  .zero 13)
 
 .text
 
-/* 
- * check Processor type: 386, 486, 6x86(L) or CPUID capable processor 
+/*
+ * check Processor type: 386, 486, 6x86(L) or CPUID capable processor
  */
 ENTRY (_w32_CheckCpuType)
     pushl %ebp
@@ -57,14 +57,14 @@ ENTRY (_w32_CheckCpuType)
     pushfl                          /* save EFLAGS */
     pushfl                          /* Get EFLAGS in EAX */
     popl %eax
-    
+
     movl  %eax, %ecx                /* save original EFLAGS in ECX */
     xorl  $EFLAGS_ALIGN_CHECK, %eax /* flip AC bit in EAX */
     pushl %eax                      /* set EAX as EFLAGS */
-    popfl           
+    popfl
     pushfl                          /* Get new EFLAGS in EAX */
     popl  %eax
-    
+
     xorl  %ecx, %eax                /* check if AC bit changed */
     andl  $EFLAGS_ALIGN_CHECK,%eax
     je is386                        /* If not : we have a 386 */
@@ -75,21 +75,21 @@ ENTRY (_w32_CheckCpuType)
     movl  %ecx, %eax                /* Restore orig EFLAGS in EAX */
     xorl  $EFLAGS_ID, %eax          /* flip  ID flag */
     pushl %eax                      /* set EAX as EFLAGS */
-    popfl               
+    popfl
     pushfl                          /* Get new EFLAGS in EAX */
     popl  %eax
-            
+
     xorl  %ecx, %eax                /* check if ID bit changed */
     andl  $EFLAGS_ID, %eax
 
-    /* 
+    /*
      * if we are on a straight 486DX, SX, or 487SX we can't
      * change it. OTOH 6x86MXs and MIIs check OK.
      * Also if we are on a Cyrix 6x86(L)
      */
     je is486x
 
-isnew:  
+isnew:
     /* restore original EFLAGS
      */
     popfl
@@ -102,22 +102,22 @@ isnew:  
      * by using it with EAX = 1
      */
     movl $1, %eax
-    cpuid           
+    cpuid
 
     movb %al, %cl                 /* save reg for future use */
-    
+
     andb $0x0F, %ah               /* mask processor family (bit 8-11) */
     movb %ah, _C_LABEL(x86_type)  /* put result in x86_type (0..15) */
 
     andb $0xF0, %al               /* get model (bit 4-7) */
     shrb $4, %al
     movb %al, _C_LABEL(x86_model) /* store it in x86_model */
-    
+
     andb $0x0F, %cl               /* get mask revision */
     movb %cl, _C_LABEL(x86_mask)  /* store it in x86_mask */
-    
+
     movl %edx, _C_LABEL(x86_capability) /* store feature flags */
-    
+
     /* get vendor info by using CPUID with EAX = 0
      */
     xorl %eax, %eax
@@ -153,7 +153,7 @@ is486x:
     div  %bl
     lahf
     cmpb $2, %ah
-    jne  ncyrix
+    jne  is386
 
     /*
      * N.B. The pattern of accesses to 0x22 and 0x23 is *essential*
@@ -184,10 +184,16 @@ is486x:
     movw %ax, %bx           /* to enable CPUID execution */
     setCx86 ($0xE8, %bx)
 
-    getCx86 ($0xFE)         /* DIR0 : let's check this is a 6x86(L) */
+    /* Must check cpu id regs here and not after trying to set CCR3
+     * to avoid failure when testing SG Microelectronic STPCs, which
+     * lock up if you try to enable cpuid execution
+     */
+
+    getCx86 ($0xFE)         /* DIR0 : let's check if this is a 6x86(L) */
     andw $0xF0, %ax         /* should be 3xh */
-    cmpw $0x30, %ax
-    jne n6x86
+    cmpw $0x30, %ax         /* STPCs return 0x80, 0x1a, 0x1b or 0x1f */
+    jne  is386
+
     getCx86 ($0xE9)         /* CCR5 : we reset the SLOP bit */
     andw $0xFD, %ax         /* so that udelay calculation */
     movw %ax, %bx           /* is correct on 6x86(L) CPUs */
@@ -197,16 +203,6 @@ is486x:
     sti
     jmp isnew               /* We enabled CPUID now */
 
-n6x86:
-    setCx86 ($0xC3, %cx)    /* Restore old CCR3 */
-    sti
-
-ncyrix:
-    popfl                   /* restore original EFLAGS */
-    call check_x87
-    popl %ebx
-    jmp  end_CheckCpuType
-
 is386:
     popfl                   /* restore original EFLAGS */
     call check_x87
diff -urp watt_src.orig/src/cpumodel.h watt_src/src/cpumodel.h
--- watt_src.orig/src/cpumodel.h	2005-12-29 23:47:56.000000000 +0200
+++ watt_src/src/cpumodel.h	2015-05-01 05:55:00.000000000 +0300
@@ -156,7 +156,7 @@ extern CONST char  DATA_DECL x86_vendor_
   /*
    * Call this only if x86_have_cpuid == TRUE.
    */
-  /*@unused@*/ extern __inline__ void get_cpuid (DWORD val, DWORD *eax,
+  /*@unused@*/ _W32_EXTERN_INLINE void get_cpuid(DWORD val, DWORD *eax,
                                                  DWORD *ebx,DWORD *ecx,
                                                  DWORD *edx)
   {
@@ -177,7 +177,7 @@ extern CONST char  DATA_DECL x86_vendor_
    *   Tom Burgess <Tom_Burgess@bc.sympatico.ca> and
    *   Douglas Eleveld <deleveld@dds.nl>
    */
-  extern __inline__ uint64 get_rdtsc (void)
+  _W32_EXTERN_INLINE uint64 get_rdtsc (void)
   {
     register uint64 tsc;
     __asm__ __volatile__ (
@@ -186,7 +186,7 @@ extern CONST char  DATA_DECL x86_vendor_
     return (tsc);
   }
 
-  extern __inline__ void get_rdtsc2 (struct ulong_long *tsc)
+  _W32_EXTERN_INLINE void get_rdtsc2 (struct ulong_long *tsc)
   {
     __asm__ __volatile__ (
               ".byte 0x0F, 0x31;"
@@ -291,7 +291,7 @@ static void pkt_restore_fpu (char far *s
  * Note used at the moment. See cpumodel.asm instead.
  */
 #if defined(__GNUC__)
-extern __inline__ BOOL have_cpuid (void)
+_W32_EXTERN_INLINE BOOL have_cpuid (void)
 {
   int result = -1;
 
diff -urp watt_src.orig/src/djgpp/syserr.c watt_src/src/djgpp/syserr.c
--- watt_src.orig/src/djgpp/syserr.c	2005-12-29 22:10:20.000000000 +0200
+++ watt_src/src/djgpp/syserr.c	2015-06-28 10:55:28.000000000 +0300
@@ -1,5 +1,5 @@
 /*
- * THIS FILE WAS GENERATED BY e:/net/watt/util/dj_err.exe. DO NOT EDIT.
+ * THIS FILE WAS GENERATED BY c:/net/watt/util/dj_err.exe. DO NOT EDIT.
  *
  * Watt-32 sys_errlist replaces vendor's sys_errlist
  */
@@ -8,7 +8,6 @@
 #error This file is only for use by "__DJGPP__"
 #endif
 
-char __syserr39[] = "Operation would block (EWOULDBLOCK)";
 char __syserr01[] = "Input to function out of range (EDOM)";
 char __syserr02[] = "Output of function out of range (ERANGE)";
 char __syserr03[] = "Argument list too long (E2BIG)";
@@ -47,63 +46,64 @@ char __syserr35[] = "Invalid seek (ESPIP
 char __syserr36[] = "No such process (ESRCH)";
 char __syserr37[] = "Improper link (EXDEV)";
 char __syserr38[] = "No more files (ENMFILE)";
-char __syserr40[] = "Operation now in progress (EINPROGRESS)";
-char __syserr41[] = "Operation already in progress (EALREADY)";
-char __syserr42[] = "Socket operation on non-socket (ENOTSOCK)";
-char __syserr43[] = "Destination address required (EDESTADDRREQ)";
-char __syserr44[] = "Message too long (EMSGSIZE)";
-char __syserr45[] = "Protocol wrong type for socket (EPROTOTYPE)";
-char __syserr46[] = "Protocol option not available (ENOPROTOOPT)";
-char __syserr47[] = "Protocol not supported (EPROTONOSUPPORT)";
-char __syserr48[] = "Socket type not supported (ESOCKTNOSUPPORT)";
-char __syserr49[] = "Operation not supported on socket (EOPNOTSUPP)";
-char __syserr50[] = "Protocol family not supported (EPFNOSUPPORT)";
-char __syserr51[] = "Address family not supported by protocol (EAFNOSUPPORT)";
-char __syserr52[] = "Address already in use (EADDRINUSE)";
-char __syserr53[] = "Can't assign requested address (EADDRNOTAVAIL)";
-char __syserr54[] = "Network is down (ENETDOWN)";
-char __syserr55[] = "Network is unreachable (ENETUNREACH)";
-char __syserr56[] = "Network dropped connection on reset (ENETRESET)";
-char __syserr57[] = "Software caused connection abort (ECONNABORTED)";
-char __syserr58[] = "Connection reset by peer (ECONNRESET)";
-char __syserr59[] = "No buffer space available (ENOBUFS)";
-char __syserr60[] = "Socket is already connected (EISCONN)";
-char __syserr61[] = "Socket is not connected (ENOTCONN)";
-char __syserr62[] = "Can't send after socket shutdown (ESHUTDOWN)";
-char __syserr63[] = "Connection timed out (ETIMEDOUT)";
-char __syserr64[] = "Connection refused (ECONNREFUSED)";
-char __syserr65[] = "Host is down (EHOSTDOWN)";
-char __syserr66[] = "No route to host (EHOSTUNREACH)";
-char __syserr67[] = "Stale NFS file handle (ESTALE)";
-char __syserr68[] = "Too many levels of remote in path (EREMOTE)";
-char __syserr69[] = "RPC struct is bad (EBADRPC)";
-char __syserr70[] = "RPC version wrong (ERPCMISMATCH)";
-char __syserr71[] = "RPC prog. not avail (EPROGUNAVAIL)";
-char __syserr72[] = "RPC Program version wrong (EPROGMISMATCH)";
-char __syserr73[] = "Bad procedure for program (EPROCUNAVAIL)";
-char __syserr74[] = "Multibyte/wide character encoding error (EILSEQ)";
-char __syserr75[] = "Invalid function number (EINVFNC)";
-char __syserr76[] = "Path not found (ENOPATH)";
-char __syserr77[] = "Memory area destroyed (ECONTR)";
-char __syserr78[] = "Invalid memory block address (EINVMEM)";
-char __syserr79[] = "Invalid environment (EINVENV)";
-char __syserr80[] = "Invalid format (EINVFMT)";
-char __syserr81[] = "Invalid access code (EINVACC)";
-char __syserr82[] = "Invalid data (EINVDAT)";
-char __syserr83[] = "Locking violation (EDEADLOCK)";
-char __syserr84[] = "Attempt to remove current directory (ECURDIR)";
-char __syserr85[] = "Not same device (ENOTSAM)";
-char __syserr86[] = "Text file busy (ETXTBSY)";
-char __syserr87[] = "Block device required (ENOTBLK)";
-char __syserr88[] = "Structure needs cleaning (EUCLEAN)";
-char __syserr89[] = "Too many references (ETOOMANYREFS)";
-char __syserr90[] = "Too many levels of symbolic links (ELOOP)";
-char __syserr91[] = "Too many processes (EPROCLIM)";
-char __syserr92[] = "Too many users (EUSERS)";
-char __syserr93[] = "Disc quota exceeded (EDQUOT)";
-char __syserr94[] = "RVD related disk error (EVDBAD)";
-char __syserr95[] = "Out of remote working directory stuctures (ENORMTWD)";
-char __syserr96[] = "Value too large (EOVERFLOW)";
+char __syserr39[] = "Too many levels of symbolic links (ELOOP)";
+char __syserr40[] = "Value too large (EOVERFLOW)";
+char __syserr41[] = "Invalid or incomplete multibyte or wide character (EILSEQ)";
+char __syserr42[] = "Operation would block (EWOULDBLOCK)";
+char __syserr43[] = "Operation now in progress (EINPROGRESS)";
+char __syserr44[] = "Operation already in progress (EALREADY)";
+char __syserr45[] = "Socket operation on non-socket (ENOTSOCK)";
+char __syserr46[] = "Destination address required (EDESTADDRREQ)";
+char __syserr47[] = "Message too long (EMSGSIZE)";
+char __syserr48[] = "Protocol wrong type for socket (EPROTOTYPE)";
+char __syserr49[] = "Protocol option not available (ENOPROTOOPT)";
+char __syserr50[] = "Protocol not supported (EPROTONOSUPPORT)";
+char __syserr51[] = "Socket type not supported (ESOCKTNOSUPPORT)";
+char __syserr52[] = "Operation not supported on socket (EOPNOTSUPP)";
+char __syserr53[] = "Protocol family not supported (EPFNOSUPPORT)";
+char __syserr54[] = "Address family not supported by protocol (EAFNOSUPPORT)";
+char __syserr55[] = "Address already in use (EADDRINUSE)";
+char __syserr56[] = "Can't assign requested address (EADDRNOTAVAIL)";
+char __syserr57[] = "Network is down (ENETDOWN)";
+char __syserr58[] = "Network is unreachable (ENETUNREACH)";
+char __syserr59[] = "Network dropped connection on reset (ENETRESET)";
+char __syserr60[] = "Software caused connection abort (ECONNABORTED)";
+char __syserr61[] = "Connection reset by peer (ECONNRESET)";
+char __syserr62[] = "No buffer space available (ENOBUFS)";
+char __syserr63[] = "Socket is already connected (EISCONN)";
+char __syserr64[] = "Socket is not connected (ENOTCONN)";
+char __syserr65[] = "Can't send after socket shutdown (ESHUTDOWN)";
+char __syserr66[] = "Connection timed out (ETIMEDOUT)";
+char __syserr67[] = "Connection refused (ECONNREFUSED)";
+char __syserr68[] = "Host is down (EHOSTDOWN)";
+char __syserr69[] = "No route to host (EHOSTUNREACH)";
+char __syserr70[] = "Stale NFS file handle (ESTALE)";
+char __syserr71[] = "Too many levels of remote in path (EREMOTE)";
+char __syserr72[] = "RPC struct is bad (EBADRPC)";
+char __syserr73[] = "RPC version wrong (ERPCMISMATCH)";
+char __syserr74[] = "RPC prog. not avail (EPROGUNAVAIL)";
+char __syserr75[] = "RPC Program version wrong (EPROGMISMATCH)";
+char __syserr76[] = "Bad procedure for program (EPROCUNAVAIL)";
+char __syserr77[] = "Invalid function number (EINVFNC)";
+char __syserr78[] = "Path not found (ENOPATH)";
+char __syserr79[] = "Memory area destroyed (ECONTR)";
+char __syserr80[] = "Invalid memory block address (EINVMEM)";
+char __syserr81[] = "Invalid environment (EINVENV)";
+char __syserr82[] = "Invalid format (EINVFMT)";
+char __syserr83[] = "Invalid access code (EINVACC)";
+char __syserr84[] = "Invalid data (EINVDAT)";
+char __syserr85[] = "Locking violation (EDEADLOCK)";
+char __syserr86[] = "Attempt to remove current directory (ECURDIR)";
+char __syserr87[] = "Not same device (ENOTSAM)";
+char __syserr88[] = "Text file busy (ETXTBSY)";
+char __syserr89[] = "Block device required (ENOTBLK)";
+char __syserr90[] = "Structure needs cleaning (EUCLEAN)";
+char __syserr91[] = "Too many references (ETOOMANYREFS)";
+char __syserr92[] = "Too many processes (EPROCLIM)";
+char __syserr93[] = "Too many users (EUSERS)";
+char __syserr94[] = "Disc quota exceeded (EDQUOT)";
+char __syserr95[] = "RVD related disk error (EVDBAD)";
+char __syserr96[] = "Out of remote working directory stuctures (ENORMTWD)";
 
 char *SYS_ERRLIST[] = {
     __syserr00,  __syserr01,  __syserr02,  __syserr03,  __syserr04, 
diff -urp watt_src.orig/src/djgpp/watt32.dep watt_src/src/djgpp/watt32.dep
--- watt_src.orig/src/djgpp/watt32.dep	2009-03-07 17:23:44.000000000 +0200
+++ watt_src/src/djgpp/watt32.dep	2014-04-25 23:55:50.000000000 +0300
@@ -38,7 +38,7 @@ $(OBJDIR)/getopt.o: getopt.c wattcp.h la
 $(OBJDIR)/getserv.o: getserv.c wattcp.h strings.h misc.h language.h netaddr.h pcconfig.h get_xby.h pcdbug.h sock_ini.h
 $(OBJDIR)/gettod.o: gettod.c wattcp.h misc.h timer.h x32vm.h cpumodel.h strings.h gettod.h printk.h getopt.h
 $(OBJDIR)/highc.o: highc.c wattcp.h strings.h pcconfig.h
-$(OBJDIR)/idna.o: idna.c wattcp.h misc.h strings.h pcconfig.h punycode.h idna.h iconv/ascii.h iconv/jisx0201.h iconv/jisx0208.h iconv/cp437.h iconv/cp737.h iconv/cp775.h iconv/cp850.h iconv/cp852.h iconv/cp853.h iconv/cp855.h iconv/cp856.h iconv/cp857.h iconv/cp858.h iconv/cp860.h iconv/cp861.h iconv/cp862.h iconv/cp863.h iconv/cp864.h iconv/cp865.h iconv/cp866.h iconv/cp869.h iconv/cp874.h iconv/cp922.h iconv/cp932.h iconv/cp943.h iconv/ksc5601.h iconv/cp949.h iconv/big5.h iconv/cp950.h iconv/cp1046.h iconv/cp1124.h iconv/cp1125.h iconv/cp1129.h iconv/cp1133.h iconv/cp1161.h iconv/cp1162.h iconv/cp1163.h iconv/cp1250.h iconv/cp1251.h iconv/cp1252.h iconv/cp1253.h iconv/cp1254.h iconv/cp1255.h iconv/cp1256.h iconv/cp1257.h iconv/vietcomb.h iconv/cp1258.h sock_ini.h udp_dom.h pcdbug.h getopt.h
+$(OBJDIR)/idna.o: idna.c wattcp.h misc.h strings.h pcconfig.h punycode.h idna.h sock_ini.h udp_dom.h pcdbug.h getopt.h
 $(OBJDIR)/ioctl.o: ioctl.c socket.h
 $(OBJDIR)/ip4_frag.o: ip4_frag.c wattcp.h strings.h language.h misc.h timer.h chksum.h pcconfig.h pcqueue.h pcstat.h pcpkt.h pcicmp.h pctcp.h pcdbug.h netaddr.h ip4_in.h ip4_out.h ip4_frag.h sock_ini.h loopback.h pcarp.h getopt.h
 $(OBJDIR)/ip4_in.o: ip4_in.c wattcp.h misc.h chksum.h rs232.h pcconfig.h pcmulti.h pcdbug.h pcsed.h pctcp.h pcstat.h pcicmp.h ip4_frag.h ip4_in.h
@@ -64,7 +64,7 @@ pcarp.h: pcsarp.h
 $(OBJDIR)/pcbootp.o: pcbootp.c copyrigh.h wattcp.h strings.h language.h udp_dom.h syslog2.h misc.h timer.h netaddr.h pctcp.h pcsed.h pcarp.h pcconfig.h pcqueue.h pcpkt.h pcbootp.h
 $(OBJDIR)/pcbuf.o: pcbuf.c copyrigh.h wattcp.h language.h misc.h strings.h pctcp.h pcdbug.h pcbuf.h
 $(OBJDIR)/pcconfig.o: pcconfig.c copyrigh.h wattcp.h strings.h misc.h timer.h language.h udp_dom.h netaddr.h bsdname.h pcqueue.h pcdbug.h pcsed.h pcpkt.h pctcp.h pcarp.h pcrarp.h pcdhcp.h pcbootp.h pcicmp.h sock_ini.h ip4_frag.h ip4_out.h ip6_out.h loopback.h get_xby.h printk.h pcconfig.h pcicmp6.h teredo64.h getopt.h
-$(OBJDIR)/pcdbug.o: pcdbug.c wattcp.h strings.h udp_dom.h misc.h timer.h sock_ini.h chksum.h ip4_in.h ip6_in.h ip6_out.h pctcp.h pcsed.h pcarp.h pcqueue.h pcpkt.h pcstat.h pcicmp.h pcicmp6.h pcconfig.h netaddr.h language.h printk.h gettod.h pppoe.h ppp.h split.h bsddbug.h pcdbug.h zlib/zlib.h
+$(OBJDIR)/pcdbug.o: pcdbug.c wattcp.h strings.h udp_dom.h misc.h timer.h sock_ini.h chksum.h ip4_in.h ip6_in.h ip6_out.h pctcp.h pcsed.h pcarp.h pcqueue.h pcpkt.h pcstat.h pcicmp.h pcicmp6.h pcconfig.h netaddr.h language.h printk.h gettod.h pppoe.h ppp.h split.h bsddbug.h pcdbug.h
 $(OBJDIR)/pcdhcp.o: pcdhcp.c wattcp.h strings.h language.h misc.h timer.h udp_dom.h netaddr.h bsdname.h ip4_out.h syslog2.h sock_ini.h printk.h tftp.h pctcp.h pcsed.h pcarp.h pcqueue.h pcdbug.h pcpkt.h pcconfig.h pcbootp.h pcdhcp.h
 $(OBJDIR)/pcicmp.o: pcicmp.c copyrigh.h wattcp.h strings.h language.h misc.h timer.h chksum.h ip4_in.h pctcp.h pcsed.h pcarp.h pcstat.h pcdbug.h pcqueue.h pcconfig.h pcpkt.h pcping.h sock_ini.h netaddr.h ip4_out.h pcicmp.h
 $(OBJDIR)/pcicmp6.o: pcicmp6.c wattcp.h misc.h timer.h chksum.h strings.h netaddr.h language.h ip6_in.h ip6_out.h ip4_out.h split.h pctcp.h pcsed.h pcstat.h pcdbug.h pcpkt.h pcarp.h pcconfig.h pcicmp6.h
diff -urp watt_src.orig/src/djgpp.mak watt_src/src/djgpp.mak
--- watt_src.orig/src/djgpp.mak	2009-03-07 18:10:57.000000000 +0200
+++ watt_src/src/djgpp.mak	2012-09-15 20:00:50.000000000 +0300
@@ -118,11 +118,10 @@ PKT_STUB = pkt_stub.h
 ########################################################################
 
 
-CC     = gcc
-CFLAGS = -O2 -g -gcoff -I. -I../inc -W -Wall -fno-strength-reduce \
-         -ffast-math #-ffunction-sections -fomit-frame-pointer
+CC     = i586-pc-msdosdjgpp-gcc
+CFLAGS = -O2 -I. -I../inc -W -Wall -ffast-math -fomit-frame-pointer
 
-AS     = as --gdwarf2
+AS     = i586-pc-msdosdjgpp-as
 TARGET = ../lib/libwatt.a
 OBJDIR = djgpp
 
@@ -134,8 +133,8 @@ ZLIB_OBJS := $(subst .obj,.o,$(ZLIB_OBJS
 
 all: $(PKT_STUB) $(TARGET)
 
-$(TARGET): $(OBJS) $(ZLIB_OBJS)
-	ar rs $@ $?
+$(TARGET): $(OBJS)
+	i586-pc-msdosdjgpp-ar rs $@ $?
 
 $(ZLIB_OBJS):
 	$(MAKE) -f djgpp.mak -C zlib
@@ -154,20 +153,12 @@ language.c: language.l
 	flex -8 -o$@ $<
 
 clean:
-	rm -f $(TARGET) $(OBJDIR)/*.o $(OBJDIR)/*.iS $(PKT_STUB)
+	rm -f $(TARGET) $(OBJDIR)/*.o $(OBJDIR)/*.iS $(PKT_STUB) asmpkt.lst asmpkt.bin ../util/bin2c
 	@echo Cleaning done
 
 -include djgpp/watt32.dep
 
 
-########################################################################
-
-
-########################################################################
-
-
-########################################################################
-
 doxygen:
 	doxygen doxyfile
 
@@ -175,7 +166,8 @@ doxygen:
 $(OBJDIR)/pcpkt.o: asmpkt.nas
 
 $(PKT_STUB): asmpkt.nas
-	../util/nasm32 -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
+	nasm -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
+	gcc -Wall -W ../util/bin2c.c -o ../util/bin2c
 	../util/bin2c asmpkt.bin > $@
 
 
diff -urp watt_src.orig/src/djimport.c watt_src/src/djimport.c
--- watt_src.orig/src/djimport.c	2004-11-17 20:08:02.000000000 +0200
+++ watt_src/src/djimport.c	2014-04-24 10:50:00.000000000 +0300
@@ -424,7 +424,7 @@ static void *open_module (const char *mo
   sym->_go32_info_block                            = _go32_info_block;
   sym->_go32_want_ctrl_break                       = _go32_want_ctrl_break;
   sym->_write                                      = _write;
-  sym->access                                      = access;
+  sym->_chmod                                      = _chmod;
   sym->atexit                                      = atexit;
   sym->atoi                                        = atoi;
   sym->atol                                        = atol;
diff -urp watt_src.orig/src/dxe_sym.h watt_src/src/dxe_sym.h
--- watt_src.orig/src/dxe_sym.h	2004-07-25 22:14:06.000000000 +0300
+++ watt_src/src/dxe_sym.h	2014-04-24 10:50:00.000000000 +0300
@@ -122,7 +122,7 @@ struct st_symbol
   int            (*_go32_dpmi_lock_data) (void *, unsigned long);
   void           (*_go32_want_ctrl_break) (int);
   ssize_t        (*_write) (int, const void *, size_t);
-  int            (*access) (const char *, int);
+  int            (*_chmod) (const char *, int, ...);
   int            (*atexit) (void (*func)(void));
   int            (*atoi) (const char *);
   long           (*atol) (const char *);
@@ -286,7 +286,7 @@ extern struct st_symbol_t import_export;
 #define _go32_info_block                            import_export._go32_info_block
 #define _go32_want_ctrl_break                       import_export._go32_want_ctrl_break
 #define _write                                      import_export._write
-#define access                                      import_export.access
+#define _chmod                                      import_export._chmod
 #define atexit                                      import_export.atexit
 #define atoi                                        import_export.atoi
 #define atol                                        import_export.atol
diff -urp watt_src.orig/src/get_ai.c watt_src/src/get_ai.c
--- watt_src.orig/src/get_ai.c	2006-01-07 00:42:12.000000000 +0200
+++ watt_src/src/get_ai.c	2014-05-20 20:02:00.000000000 +0300
@@ -522,10 +522,11 @@ static int explore_fqdn (const struct ad
                          const char *servname, struct addrinfo **res)
 {
   const struct afd *afd;
-  struct hostent   *hp;
+  struct hostent  copy, *hp;
   struct addrinfo sentinel, *cur;
-  int    error, af, i;
-  char  *ap;
+  struct in6_addr addr [MAX_ADDRESSES+1];
+  char           *list [MAX_ADDRESSES+1], *ap;
+  int             af, i, error;
 
 #ifdef TEST_PROG
   SOCK_DEBUGF (("\nexplore_fqdn"));
@@ -588,23 +589,17 @@ static int explore_fqdn (const struct ad
    * fill_hostent(), the contents will be destroyed in below
    * get_name() otherwise.
    */
+  copy = *hp;
+  memset (&addr, 0, sizeof(addr));
+  memset (&list, 0, sizeof(list));
+  for (i = 0; hp->h_addr_list[i]; i++)
   {
-    struct hostent copy;
-    struct in6_addr addr [MAX_ADDRESSES+1];
-    char           *list [MAX_ADDRESSES+1];
-
-    copy = *hp;
-    memset (&addr, 0, sizeof(addr));
-    memset (&list, 0, sizeof(list));
-    for (i = 0; hp->h_addr_list[i]; i++)
-    {
-      memcpy (&addr[i], hp->h_addr_list[i], hp->h_length);
-      list[i] = (char*) &addr[i];
-    }
-    list[i]          = NULL;
-    copy.h_addr_list = list;
-    hp = &copy;
+    memcpy (&addr[i], hp->h_addr_list[i], hp->h_length);
+    list[i] = (char*) &addr[i];
   }
+  list[i]          = NULL;
+  copy.h_addr_list = list;
+  hp = &copy;
 
   for (i = 0; hp->h_addr_list[i]; i++)
   {
diff -urp watt_src.orig/src/gethost.c watt_src/src/gethost.c
--- watt_src.orig/src/gethost.c	2005-11-30 23:33:30.000000000 +0200
+++ watt_src/src/gethost.c	2014-05-20 20:02:00.000000000 +0300
@@ -562,7 +562,7 @@ static BOOL gethostbyaddr_internal (cons
   {
     int i;
 
-    for (i = 0; h->h_address[i] != INADDR_NONE && i < h->h_num_addr; i++)
+    for (i = 0; i < h->h_num_addr && h->h_address[i] != INADDR_NONE; i++)
     {
       if (addr == h->h_address[i])
       {
diff -urp watt_src.orig/src/getnet.c watt_src/src/getnet.c
--- watt_src.orig/src/getnet.c	2005-10-12 01:17:18.000000000 +0300
+++ watt_src/src/getnet.c	2013-12-12 12:10:00.000000000 +0200
@@ -179,7 +179,7 @@ struct netent * W32_CALL getnetent (void
   char   buf [2*MAX_NAMELEN], *tok;
   int    i;
 
-  if (!netdb_init())
+  if (!netdb_init() || !networkFile)
      return (NULL);
 
   while (1)
Only in watt_src.orig/src: iconv
diff -urp watt_src.orig/src/ioport.h watt_src/src/ioport.h
--- watt_src.orig/src/ioport.h	2003-11-14 00:57:54.000000000 +0200
+++ watt_src/src/ioport.h	2015-05-01 05:55:00.000000000 +0300
@@ -61,7 +61,7 @@
 
 /* Copyright (C) 1995 DJ Delorie, see COPYING.DJ for details */
 
-extern __inline__ unsigned char inportb (unsigned short port)
+_W32_EXTERN_INLINE unsigned char inportb (unsigned short port)
 {
   unsigned char rc;
   __asm__ __volatile__ (
@@ -71,7 +71,7 @@ extern __inline__ unsigned char inportb
   return (rc);
 }
 
-extern __inline__ unsigned short inportw (unsigned short port)
+_W32_EXTERN_INLINE unsigned short inportw (unsigned short port)
 {
   unsigned short rc;
   __asm__ __volatile__ (
@@ -81,7 +81,7 @@ extern __inline__ unsigned short inportw
   return (rc);
 }
 
-extern __inline__ void outportb (unsigned short port, unsigned char data)
+_W32_EXTERN_INLINE void outportb (unsigned short port, unsigned char data)
 {
   __asm__ __volatile__ (
              "outb %1, %0"
@@ -89,7 +89,7 @@ extern __inline__ void outportb (unsigne
              "a" (data));
 }
 
-extern __inline__ void outportw (unsigned short port, unsigned short data)
+_W32_EXTERN_INLINE void outportw (unsigned short port, unsigned short data)
 {
   __asm__ __volatile__ (
              "outw %1, %0"
diff -urp watt_src.orig/src/misc.c watt_src/src/misc.c
--- watt_src.orig/src/misc.c	2006-01-15 06:27:48.000000000 +0200
+++ watt_src/src/misc.c	2015-06-28 10:55:28.000000000 +0300
@@ -1640,10 +1640,12 @@ static void stk_overflow (void _far *whe
 #undef _w32_IOPORT_H
 #undef BEEP
 #undef WIN_ASSERT
+#undef _W32_EXTERN_INLINE
 
 #define extern
 #define __inline__
 #define __inline
+#define _W32_EXTERN_INLINE
 
 #if defined(__MINGW32__) || defined(__CYGWIN__)
   #undef intel
diff -urp watt_src.orig/src/misc.h watt_src/src/misc.h
--- watt_src.orig/src/misc.h	2006-01-13 00:06:34.000000000 +0200
+++ watt_src/src/misc.h	2015-05-01 05:55:00.000000000 +0300
@@ -730,7 +730,7 @@ extern const char *short_strerror (int e
    * save/restore FS/GS registers in the rmode callback stub.
    * Not needed if 'USE_FAST_PKT' is used.
    */
-  extern __inline__ WORD get_fs_reg (void)
+  _W32_EXTERN_INLINE WORD get_fs_reg (void)
   {
      WORD sel;
      __asm__ __volatile__ (
@@ -738,7 +738,7 @@ extern const char *short_strerror (int e
            : "=r" (sel) : );
      return (sel);
   }
-  extern __inline__ WORD get_gs_reg (void)
+  _W32_EXTERN_INLINE WORD get_gs_reg (void)
   {
      WORD sel;
      __asm__ __volatile__ (
@@ -746,13 +746,13 @@ extern const char *short_strerror (int e
            : "=r" (sel) : );
      return (sel);
   }
-  extern __inline__ void set_fs_reg (WORD sel)
+  _W32_EXTERN_INLINE void set_fs_reg (WORD sel)
   {
     __asm__ __volatile__ (
             "movw %w0, %%fs"
          :: "rm" (sel));
   }
-  extern __inline__ void set_gs_reg (WORD sel)
+  _W32_EXTERN_INLINE void set_gs_reg (WORD sel)
   {
     __asm__ __volatile__ (
             "movw %w0, %%gs"
diff -urp watt_src.orig/src/netaddr.c watt_src/src/netaddr.c
--- watt_src.orig/src/netaddr.c	2005-12-14 01:18:58.000000000 +0200
+++ watt_src/src/netaddr.c	2015-11-01 12:10:10.000000000 +0200
@@ -205,7 +205,7 @@ const char *_inet_atoeth (const char *sr
 #if (DOSX)
   int tmp [sizeof(eth_address)];
 
-  if (!sscanf(src,"%02x:%02x:%02x:%02x:%02x:%02x",
+  if (sscanf(src,"%02x:%02x:%02x:%02x:%02x:%02x",
               &tmp[0], &tmp[1], &tmp[2],
               &tmp[3], &tmp[4], &tmp[5]) != DIM(tmp))
      return (NULL);
diff -urp watt_src.orig/src/packet32.c watt_src/src/packet32.c
--- watt_src.orig/src/packet32.c	2005-02-19 19:05:50.000000000 +0200
+++ watt_src/src/packet32.c	2011-03-03 18:05:19.000000000 +0200
@@ -47,7 +47,7 @@
 #include "strings.h"
 #include "pcconfig.h"
 #include "pcdbug.h"
-#include "NtddNdis.h"
+#include "ntddndis.h"
 #include "cpumodel.h"
 #include "packet32.h"
 
diff -urp watt_src.orig/src/pcconfig.c watt_src/src/pcconfig.c
--- watt_src.orig/src/pcconfig.c	2005-10-01 21:10:54.000000000 +0300
+++ watt_src/src/pcconfig.c	2014-04-24 10:50:00.000000000 +0300
@@ -584,7 +584,11 @@ static long do_include_file (const char 
     return (0);
   }
 
+#ifdef __DJGPP__
+  if (_chmod(p, 0) != -1)
+#else
   if (access(p, 0) == 0)
+#endif
   {
     /* Recursion, but we're reentrant.
      * !!Fix-me: recursion depth should be limited.
@@ -1065,8 +1069,12 @@ int tcp_config_name (char *name, int max
       *temp = '\0';
     }
   }
-  else if (access(config_name,0) == 0)  /* found in current directory */
-  {
+#ifdef __DJGPP__
+  else if (_chmod(config_name,0) != -1)
+#else
+  else if (access(config_name,0) == 0)
+#endif
+  { /* found in current directory */
     strcpy (name, ".\\");
     path = name;
   }
@@ -1133,7 +1141,11 @@ long tcp_config (const char *path)
   {
     fname = name;
     StrLcpy (name, path, sizeof(name));
+#ifdef __DJGPP__
+    if (_chmod(fname,0) == -1)
+#else
     if (access(fname,0) != 0)
+#endif
        goto not_found;
   }
 
diff -urp watt_src.orig/src/pcdhcp.c watt_src/src/pcdhcp.c
--- watt_src.orig/src/pcdhcp.c	2005-07-01 00:47:22.000000000 +0300
+++ watt_src/src/pcdhcp.c	2014-05-20 20:02:00.000000000 +0300
@@ -60,6 +60,11 @@
  *
  *  \version 0.93: Jul 2, 2004:
  *    Fixed logic around reading transient config.
+ *
+ *  \version 0.94: Oct 22, 2007:
+ *    Fixes for Linux dhcp servers: parse dhcp options in ACK msgs.
+ *    Changed DHCP_do_boot() to handle renew and rebind as well as init.
+ *    Renegotiate lease if past the renew or rebind times.
  */
 
 #include <stdio.h>
@@ -331,6 +336,10 @@ static int DHCP_request (BOOL renew)
    */
   opt = put_hardware_opt (opt);
 
+/* ... don't know why we would ever renew a lease
+ * for the time remaining on our current lease...
+ */
+#if 0
   if (dhcp_iplease && dhcp_iplease < (DWORD)-1)
   {
     *opt++ = DHCP_OPT_IP_ADDR_LEASE_TIME;
@@ -338,6 +347,7 @@ static int DHCP_request (BOOL renew)
     *(DWORD*)opt = intel (dhcp_iplease);
     opt += sizeof (dhcp_iplease);
   }
+#endif
 
   if (user_class.data)
   {
@@ -691,7 +701,7 @@ void DHCP_release (BOOL force)
 {
   if (force)
   {
-    TRACE (("Sending DHCP release\n"));
+    TRACE (("Sending DHCP release 01\n"));
     DHCP_release_decline (DHCP_RELEASE, NULL);
   }
   else if (configured)
@@ -703,7 +713,7 @@ void DHCP_release (BOOL force)
     if (!(cfg_saved &&
           (lease_timeout && (lease_timeout - time(NULL) > DHCP_MIN_LEASE))))
     {
-      TRACE (("Sending DHCP release\n"));
+      TRACE (("Sending DHCP release 02\n"));
       DHCP_release_decline (DHCP_RELEASE, NULL);
     }
   }
@@ -782,7 +792,7 @@ static void DHCP_state_BOUND (int event)
     old_ip_addr = my_ip_addr;    /* remember current address */
     got_offer   = FALSE;
 
-    TRACE (("Sending DHCP request\n"));
+    TRACE (("Sending DHCP request 01\n"));
     DHCP_request (1);
     DHCP_state = DHCP_state_RENEWING;
   }
@@ -798,12 +808,21 @@ static void DHCP_state_REQUESTING (int e
 {
   if (event == EVENT_SEND_TIMEOUT)
   {
-    TRACE (("Sending DHCP request\n"));
+    TRACE (("Sending DHCP request 00\n"));
     DHCP_request (0);
+
+    /*UPDATE: 05MAR2006 paul.suggs@vgt.net
+     *  There is a timing condition within the FSM where the state has changed
+     *  to REQUESTING but in dhcp_fsm(), chk_timeout() will be evaluated true
+     *  which sets send_timeout to 0 before the first execution of this state
+     *  handler. Once set to 0, we have to wait for rollover to resend the
+     *  above request if it is lost for some reason
+     */
+    send_timeout = set_timeout (Random(4000,6000));
   }
   else if (event == EVENT_ACK)
   {
-    TRACE (("Got DHCP ack\n"));
+    TRACE (("Got DHCP ack while requesting\n"));
 
     if (!DHCP_arp_check(my_ip_addr))
     {
@@ -814,7 +833,8 @@ static void DHCP_state_REQUESTING (int e
     }
     else
     {
-      configured = 1;     /* we are (re)configured */
+      DHCP_offer (&dhcp_in);  /* parse options in the ack too */
+      configured = 1;         /* we are (re)configured */
       if (dhcp_server)
          arp_add_server();
       dhcp_set_timers();
@@ -839,8 +859,9 @@ static void DHCP_state_REBINDING (int ev
 {
   if (event == EVENT_ACK)
   {
-    TRACE (("Got DHCP ack\n"));
+    TRACE (("Got DHCP ack while rebinding\n"));
     dhcp_set_timers();
+    DHCP_offer (&dhcp_in);
     change_ip_addr();
     DHCP_state = DHCP_state_BOUND;
   }
@@ -863,26 +884,27 @@ static void DHCP_state_RENEWING (int eve
 {
   if (event == EVENT_SEND_TIMEOUT)
   {
-    TRACE (("Sending DHCP request\n"));
+    TRACE (("Sending DHCP request for renew\n"));
     DHCP_request (1);
   }
   else if (event == EVENT_T2_TIMEOUT)
   {
-    TRACE (("Sending DHCP request\n"));
+    TRACE (("Sending DHCP request for rebind\n"));
     bcast_flag = TRUE;
     DHCP_request (1);
     DHCP_state = DHCP_state_REBINDING;
   }
   else if (event == EVENT_ACK)
   {
-    TRACE (("Got DHCP ack\n"));
+    TRACE (("Got DHCP ack while renewing\n"));
     dhcp_set_timers();
+    DHCP_offer (&dhcp_in);
     change_ip_addr();
     DHCP_state = DHCP_state_BOUND;
   }
   else if (event == EVENT_NAK)
   {
-    TRACE (("Got DHCP nack\n"));
+    TRACE (("Got DHCP nack while renewing\n"));
     send_timeout = set_timeout (Random(4000,6000));
     my_ip_addr = 0;
     DHCP_state = DHCP_state_INIT;
@@ -1014,12 +1036,12 @@ static void dhcp_fsm (void)
 }
 
 /**
- * Our first time (booting) DHCP handler.
- * Only called if:
+ * Our first time DHCP handler.
+ * Called if:
  *  - we don't have a WATTCP.CFG file
  *  - or we specified "MY_IP = DHCP".
  *  - or reading a previous W32DHCP.TMP file with transient config failed.
- *
+ *  - or lease times call for a renew or rebind.
  * It doesn't hurt that it is blocking.
  */
 int DHCP_do_boot (void)
@@ -1035,9 +1057,14 @@ int DHCP_do_boot (void)
   if (!sock)
      return (0);
 
+  if (DHCP_state != DHCP_state_RENEWING &&
+      DHCP_state != DHCP_state_REBINDING)
+  {
+    my_ip_addr = 0;
+    sin_mask   = 0;
+  }
+
   _mtu = ETH_MAX_DATA;
-  my_ip_addr = 0;
-  sin_mask   = 0;
   discover_loops = 0;
 
   erase_config();         /* delete old configuration */
@@ -1046,7 +1073,10 @@ int DHCP_do_boot (void)
   /* kick start DISCOVER message
    */
   send_timeout = set_timeout (100);
-  DHCP_state = DHCP_state_INIT;
+
+  if (DHCP_state != DHCP_state_RENEWING &&
+      DHCP_state != DHCP_state_REBINDING)
+     DHCP_state = DHCP_state_INIT;
 
   while (DHCP_state != DHCP_state_BOUND)
   {
@@ -1451,15 +1481,17 @@ static BOOL eval_timers (void)
   if (now >= cfg_dhcp_renewal && now < cfg_dhcp_rebind)
   {
     TRACE (("DHCP: RENEWING\n"));
-    DHCP_state_BOUND (EVENT_T1_TIMEOUT);    /* goto RENEWING */
-    return (TRUE);
+    DHCP_state = DHCP_state_BOUND;
+    (*DHCP_state) (EVENT_T1_TIMEOUT);       /* goto RENEWING */
+    return (FALSE);
   }
 
   if (now >= cfg_dhcp_rebind && now < cfg_dhcp_iplease)
   {
     TRACE (("DHCP: REBINDING\n"));
-    DHCP_state_RENEWING (EVENT_T2_TIMEOUT); /* goto REBINDING */
-    return (TRUE);
+    DHCP_state = DHCP_state_RENEWING;
+    (*DHCP_state) (EVENT_T2_TIMEOUT);       /* goto REBINDING */
+    return (FALSE);
   }
   return (FALSE);
 }
@@ -1543,8 +1575,12 @@ static int std_write_config (void)
   int    rc  = 0;
   const  char *fname = get_config_file();
 
-  if (access(fname,0))  /* file not found, create */
-  {
+#ifdef __DJGPP__
+  if (_chmod(fname,0) == -1)
+#else
+  if (access(fname,0) != 0)
+#endif
+  { /* file not found, create */
     file = fopen (fname, "w+t");
     if (!file)
        goto fail;
diff -urp watt_src.orig/src/pcsarp.c watt_src/src/pcsarp.c
--- watt_src.orig/src/pcsarp.c	2005-10-01 21:18:34.000000000 +0300
+++ watt_src/src/pcsarp.c	2014-04-24 10:50:10.000000000 +0300
@@ -85,7 +85,11 @@ int sarp_init (void)
   _sarp_recv_hook = sarp_receive;
   _sarp_xmit_hook = sarp_transmit;
 
+#ifdef __DJGPP__
+  if (rand && _chmod(rand,0) !=-1)
+#else
   if (rand && access(rand,0) == 0)
+#endif
        RAND_load_file (rand, -1);
   else SARP_DEBUG (0, ("Warning: No random seed file found\n"));
   return (0);
diff -urp watt_src.orig/src/pctcp.c watt_src/src/pctcp.c
--- watt_src.orig/src/pctcp.c	2005-12-05 01:32:06.000000000 +0200
+++ watt_src/src/pctcp.c	2014-05-20 20:02:00.000000000 +0300
@@ -1639,10 +1639,9 @@ static void sock_reduce_mss (sock_type *
 void _udp_cancel (const in_Header *ip, int icmp_type, int icmp_code,
                   const char *msg, const void *arg) /* use a var-arg here ? */
 {
-  WORD         src_port, dst_port, next_mtu;
-  DWORD        gateway;
-  int          len     = in_GetHdrLen (ip);
+  WORD         src_port, dst_port;
   BOOL         passive = FALSE;
+  int          len     = in_GetHdrLen (ip);
   udp_Header  *udp     = (udp_Header*) ((BYTE*)ip + len);
   _udp_Socket *s;
 
@@ -1671,24 +1670,27 @@ void _udp_cancel (const in_Header *ip, i
   {
     SET_ERR_MSG (s, msg);
 
-    /* handle redirect on active sockets
+    /* handle ICMP-errors on active sockets
      */
     if (icmp_type == ICMP_REDIRECT && !passive)
     {
+      DWORD gateway;
+
       WATT_ASSERT (arg != NULL);
       gateway = *(DWORD*)arg;
       _ip_recursion = 1;
       _arp_resolve (gateway, &s->his_ethaddr);
       _ip_recursion = 0;
     }
-    else if (icmp_type == ICMP_UNREACH && icmp_code == ICMP_UNREACH_NEEDFRAG)
+    else if (icmp_type == ICMP_UNREACH && icmp_code == ICMP_UNREACH_NEEDFRAG && !passive)
     {
+      WORD next_mtu;
+
       WATT_ASSERT (arg != NULL);
       next_mtu = *(WORD*) arg;
-      if (!passive)
-         sock_reduce_mss ((sock_type*)s, next_mtu);
+      sock_reduce_mss ((sock_type*)s, next_mtu);
     }
-    else if (icmp_type != ICMP_TIMXCEED)
+    else if (icmp_type != ICMP_TIMXCEED && !passive)
     {
       /* UDP isn't sturdy, close it on 1st ICMP error
        */
Only in watt_src.orig/src: pkt_stub.h
diff -urp watt_src.orig/src/ppp.c watt_src/src/ppp.c
--- watt_src.orig/src/ppp.c	2004-11-17 21:59:54.000000000 +0200
+++ watt_src/src/ppp.c	2014-05-20 20:02:00.000000000 +0300
@@ -1093,7 +1093,7 @@ static void std_negotiation (struct ppp_
 
   code   = *state->bp++;
   id     = *state->bp++;
-  length = intel16 (*(WORD*)&state->bp);
+  length = intel16 (*(WORD*)state->bp);  /* !! */
   if (length > state->mlen)
   {
     PRINTF (0, ("Truncated negotiation message; %d > %d\n",
@@ -1174,7 +1174,7 @@ static void std_negotiation (struct ppp_
          break;
 
     case CODE_PROTO_REJ:
-         proto = intel16 (*(WORD*)&state->bp);
+         proto = intel16 (*(WORD*)state->bp);  /* !! */
 
          /* Peer cannot reject LCP!
           */
diff -urp watt_src.orig/src/presaddr.c watt_src/src/presaddr.c
--- watt_src.orig/src/presaddr.c	2005-05-07 02:43:18.000000000 +0300
+++ watt_src/src/presaddr.c	2014-05-20 20:02:00.000000000 +0300
@@ -327,7 +327,7 @@ static int inet_pton6 (const char *src, 
          return (0);
 
       *tp++ = (u_char) (val >> 8) & 0xff;
-      *tp++ = (u_char) val & 0xff;
+      *tp++ = (u_char) (val & 0xff);
       saw_xdigit = 0;
       val = 0;
       continue;
diff -urp watt_src.orig/src/printk.c watt_src/src/printk.c
--- watt_src.orig/src/printk.c	2004-08-24 11:18:36.000000000 +0300
+++ watt_src/src/printk.c	2014-05-20 20:02:00.000000000 +0300
@@ -128,10 +128,12 @@ static void printk_exit (void)
 {
   _printk_flush();
   if (_printk_file && _printk_file != stderr && _printk_file != stdout)
-  {
     fclose (_printk_file);
-    _printk_file = NULL;
-  }
+  _printk_file = NULL;
+
+  if (printk_buf)
+     free (printk_buf);  /* Reclaim memory allocated in _printk_init() */
+  printk_buf = NULL;
 }
 
 /*
diff -urp watt_src.orig/src/src/tcp_fsm.c watt_src/src/tcp_fsm.c
--- watt_src.orig/src/tcp_fsm.c	2005-10-21 01:04:18.000000000 +0300
+++ watt_src/src/tcp_fsm.c	2015-07-15 17:11:10.000000000 +0300
@@ -1060,7 +1060,7 @@ static int tcp_process_data (_tcp_Socket
    * If it's before recv_next, we've seen it all before; if it's after
    * then the peer (or someone else) sent more than we said we could take.
    */
-  if ((unsigned)len - ldiff > s->adv_win)
+  if ((unsigned)len - ldiff > s->max_rx_data - s->rx_datalen)
   {
     TCP_TRACE (("tcp_ProcessData (%u): packet ends outside %lu/%lu\n",
                 __LINE__, s->recv_next, s->recv_next + s->adv_win));
@@ -1210,7 +1210,7 @@ static int tcp_reassemble (_tcp_Socket *
   }
 
   left_edge  = s->recv_next - s->rx_datalen;
-  right_edge = s->recv_next + s->adv_win;
+  right_edge = s->recv_next + s->max_rx_data - s->rx_datalen;
 
   /* segment is left of expected recv-window
    */
diff -urp watt_src.orig/src/timer.h watt_src/src/timer.h
--- watt_src.orig/src/timer.h	2004-09-02 17:55:22.000000000 +0300
+++ watt_src/src/timer.h	2014-05-20 20:02:00.000000000 +0300
@@ -80,12 +80,14 @@ W32_FUNC void exit_timer_isr (void);
 W32_FUNC void init_userSuppliedTimerTick (void);
 W32_FUNC void userTimerTick (DWORD elapsedTimeMs);
 
+#if (DOSX) && defined(HAVE_UINT64)
+  extern uint64 get_cpu_speed (void);
+#endif
 
 #if defined(USE_PROFILER)
   extern BOOL   profile_enable;
   extern char   profile_file [MAX_PATHLEN+1];
 
-  extern uint64 get_cpu_speed (void);
   extern void   profile_start (const char *where);
   extern void   profile_stop  (void);
   extern int    profile_init  (void);
diff -urNp watt_src.orig/src/transmit.c watt_src/src/transmit.c
--- watt_src.orig/src/transmit.c	2005-11-17 06:20:38.000000000 +0200
+++ watt_src/src/transmit.c	2016-06-25 23:55:00.000000000 +0300
@@ -334,7 +334,10 @@ static int setup_udp_raw (Socket *socket
   if (socket->so_state & SS_ISCONNECTED)
   {
     if (!socket->remote_addr)
+    {
        SOCK_FATAL (("setup_udp_raw(): no remote_addr\n"));
+       return (-1);
+    }
 
     /* No need to reconnect if same peer address/port.
      */
diff -urp watt_src.orig/src/wattcp.h watt_src/src/wattcp.h
--- watt_src.orig/src/wattcp.h	2006-01-13 00:05:08.000000000 +0200
+++ watt_src/src/wattcp.h	2015-05-01 05:55:00.000000000 +0300
@@ -131,6 +131,7 @@ struct ulong_long {
 
 #include <sys/w32api.h>      /**< export/import decorations */
 #include <sys/werrno.h>      /**< errno stuff */
+#include <sys/cdefs.h>       /**< _EXTERN_INLINE  */
 
 #if defined(USE_CRTDBG)      /**< use CrtDebug in MSVC debug-mode */
   #define _CRTDBG_MAP_ALLOC
diff -urp watt_src.orig/src/winpcap.c watt_src/src/winpcap.c
--- watt_src.orig/src/winpcap.c	2006-01-25 05:07:12.000000000 +0200
+++ watt_src/src/winpcap.c	2011-03-03 18:05:19.000000000 +0200
@@ -48,8 +48,8 @@
 #include "pcpkt.h"
 
 #include "winpcap.h"
-#include "NtddNdis.h"
-#include "Packet32.h"
+#include "ntddndis.h"
+#include "packet32.h"
 
 #if (defined(_DLL) && !defined(_MT)) && !defined(__LCC__)
 #error This file must be compiled for threads
Only in watt_src.orig/src: zlib
Binary files watt_src.orig/util/dj_err.exe and watt_src/util/dj_err.exe differ
diff -urp watt_src.orig/util/errnos.c watt_src/util/errnos.c
--- watt_src.orig/util/errnos.c	2005-12-19 04:02:20.000000000 +0200
+++ watt_src/util/errnos.c	2015-06-28 05:55:00.000000000 +0300
@@ -319,12 +319,6 @@ static const char *err_tab[] = {
 
 static void process (void)
 {
-#ifdef EWOULDBLOCK
-  ADD_ERRNO (EWOULDBLOCK);
-#else
-  NEW_ERRNO (0);
-#endif
-
 #ifdef EDOM
   ADD_ERRNO (EDOM);
 #else
@@ -553,6 +547,30 @@ static void process (void)
   NEW_ERRNO (38);
 #endif
 
+#ifdef ELOOP
+  ADD_ERRNO (ELOOP);
+#else
+  NEW_ERRNO (89);
+#endif
+
+#ifdef EOVERFLOW
+  ADD_ERRNO (EOVERFLOW);
+#else
+  NEW_ERRNO (95);
+#endif
+
+#ifdef EILSEQ
+  ADD_ERRNO (EILSEQ);
+#else
+  NEW_ERRNO (73);
+#endif
+
+#ifdef EWOULDBLOCK
+  ADD_ERRNO (EWOULDBLOCK);
+#else
+  NEW_ERRNO (0);
+#endif
+
 #ifdef EINPROGRESS
   ADD_ERRNO (EINPROGRESS);
 #else
@@ -757,12 +775,6 @@ static void process (void)
   NEW_ERRNO (72);
 #endif
 
-#ifdef EILSEQ
-  ADD_ERRNO (EILSEQ);
-#else
-  NEW_ERRNO (73);
-#endif
-
 #ifdef EINVFNC
   ADD_ERRNO (EINVFNC);
 #else
@@ -853,12 +865,6 @@ static void process (void)
   NEW_ERRNO (88);
 #endif
 
-#ifdef ELOOP
-  ADD_ERRNO (ELOOP);
-#else
-  NEW_ERRNO (89);
-#endif
-
 #ifdef EPROCLIM
   ADD_ERRNO (EPROCLIM);
 #else
@@ -888,12 +894,6 @@ static void process (void)
 #else
   NEW_ERRNO (94);
 #endif
-
-#ifdef EOVERFLOW
-  ADD_ERRNO (EOVERFLOW);
-#else
-  NEW_ERRNO (95);
-#endif
 }
 
 /*
diff -urp watt_src.orig/util/bin2c.c watt_src/util/bin2c.c
--- watt_src.orig/util/bin2c.c	1970-01-01 02:00:00.000000000 +0200
+++ watt_src/util/bin2c.c	2013-01-30 18:01:52.000000000 +0200
@@ -0,0 +1,43 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <time.h>
+
+static void Abort (const char *fmt,...)
+{
+  va_list args;
+  va_start (args, fmt);
+  vfprintf (stderr, fmt, args);
+  va_end (args);
+  exit (1);
+}
+
+int main (int argc, char **argv)
+{
+  FILE  *inFile;
+  FILE  *outFile = stdout;
+  time_t now     = time (NULL);
+  int    ch, i;
+
+  if (argc != 2)
+     Abort ("Usage: %s bin-file [> result]\n", argv[0]);
+
+  if ((inFile = fopen(argv[1],"rb")) == NULL)
+     Abort ("Cannot open %s\n", argv[1]);
+
+  fprintf (outFile,
+           "/* data statements for file %s at %.24s */\n"
+           "/* Generated by BIN2C, G. Vanem 1995 */\n",
+           argv[1], ctime(&now));
+
+  i = 0;
+  while ((ch = fgetc(inFile)) != EOF)
+  {
+    if (i++ % 12 == 0)
+       fputs ("\n  ", outFile);
+    fprintf (outFile, "0x%02X,", ch);
+  }
+  fputc ('\n', outFile);
+  fclose (inFile);
+  return (0);
+}
