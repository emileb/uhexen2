these are the differences between the old (from Raven's h2_utils package)
and new versions (from Raven's h2mputil package) of the hcc tool.

diff -urNp hcc_old/expr.c hcc/expr.c
--- hcc_old/expr.c	2011-06-02 00:15:46.000000000 +0300
+++ hcc/expr.c	2011-06-02 00:15:46.000000000 +0300
@@ -279,6 +279,11 @@ static def_t *Term (void)
 	name = PR_ParseName();
 	if ((d = ParseIntrinsicFunc(name)) != NULL)
 	{ // Found and parsed an intrinsic function
+		d->referenceCount++;
+		if (d->parentVector != NULL)
+		{
+			d->parentVector->referenceCount++;
+		}
 		return d;
 	}
 
@@ -358,6 +363,12 @@ static def_t *ParseFunctionCall (def_t *
 		PR_ParseError("not a function");
 	}
 
+	func->referenceCount++;
+	if (func->parentVector != NULL)
+	{
+		func->parentVector->referenceCount++;
+	}
+
 	argCount = 0;
 	args[0] = NULL;
 	args[1] = NULL;
@@ -516,6 +527,32 @@ static void PrecacheModel (def_t *e, int
 // PrecacheFile
 //
 //==========================================================================
+static void PrecacheFileName (const char *n, int ch)
+{
+	int		i;
+
+	for (i = 0; i < numfiles; i++)
+	{
+		if (!strcmp(n, precache_files[i]))
+		{
+			return;
+		}
+	}
+	if (numfiles == MAX_FILES)
+	{
+		Error("%s: numfiles == MAX_FILES", __thisfunc__);
+	}
+	strcpy(precache_files[i], n);
+	if (ch >= '1' && ch <= '9')
+	{
+		precache_files_block[i] = ch - '0';
+	}
+	else
+	{
+		precache_files_block[i] = 1;
+	}
+	numfiles++;
+}
 
 static void PrecacheFile (def_t *e, int ch)
 {
@@ -632,6 +669,33 @@ static def_t *ParseIntrinsicFunc (const 
 		return &def_ret;
 	}
 
+	if (!strncmp(name, "precache_file", 13))	//i put this here to keep if from going in progs.dat
+	{
+		def_ret.type = &type_void;
+		LX_Require("(");
+		if (TK_CHECK(TK_RPAREN))
+		{
+			return &def_ret;	//it's empty for some reason.
+		}
+		//i should be getting an immediate string here...
+		if (pr_token_type != tt_immediate)	//oops
+			return (NULL);
+/*			expr1  = CO_ParseImmediate();
+		if (expr1->type->type != ev_string)
+		{
+			PR_ParseError("'precache_file' : parm not a string");
+		}
+*/
+		if (pr_immediate_type != &type_string)
+		{
+			PR_ParseError("'precache_file' : parm not a string");
+		}
+		PrecacheFileName(pr_immediate_string, name[13]);
+		LX_Fetch();
+		LX_Require(")");
+
+		return &def_ret;
+	}
 	return NULL;
 }
 
diff -urNp hcc_old/hcc.c hcc/hcc.c
--- hcc_old/hcc.c	2011-06-02 00:15:46.000000000 +0300
+++ hcc/hcc.c	2011-06-02 00:15:46.000000000 +0300
@@ -227,7 +227,7 @@ static void WriteData (int crc)
 
 	if (hcc_OptimizeNameTable)
 	{
-		localName = CopyString("LOCAL+");
+		localName = CopyString("LCL+");
 	}
 
 	for (def = pr.def_head.next ; def ; def = def->next)
@@ -248,9 +248,12 @@ static void WriteData (int crc)
 			&& def->type->type != ev_field
 			&& def->scope == NULL)
 		{
-			dd->type |= DEF_SAVEGLOBAL;
+			if (strncmp (def->name,"STR_", 4) != 0)	//str_ is a special case string constant
+				dd->type |= DEF_SAVEGLOBAL;
 		}
-		if (hcc_OptimizeNameTable && def->scope != NULL)
+
+		if (hcc_OptimizeNameTable && ((def->scope != NULL) ||
+			(!(dd->type&DEF_SAVEGLOBAL)&&(def->type->type < ev_field))))
 		{
 			dd->s_name = localName;
 		}
@@ -554,6 +557,14 @@ static void PR_PrintStatement (dstatemen
 		printf ("%s", PR_GlobalString(s->a));
 		printf ("%s", PR_GlobalStringNoContents(s->b));
 	}
+	else if ( (unsigned int)(s->op - OP_SWITCH_F) < 5)
+	{
+		printf ("%sbranch %i", PR_GlobalString(s->a),s->b);
+	}
+	else if (s->op == OP_CASE)
+	{
+		printf ("of %i branch %i",s->a, s->b);
+	}
 	else
 	{
 		if (s->a)
@@ -605,10 +616,14 @@ static qboolean FinishCompilation (void)
 {
 	def_t		*d;
 	qboolean	errors;
+	qboolean	globals_done = false;
 
 	errors = false;
 	for (d = pr.def_head.next ; d ; d = d->next)
 	{
+		if (!strcmp (d->name, "end_sys_globals"))
+			globals_done = true;
+			
 		if (d->type->type == ev_function && !d->scope)
 		{
 			if (!d->initialized)
@@ -616,7 +631,7 @@ static qboolean FinishCompilation (void)
 				printf("function '%s' was not defined\n", d->name);
 				errors = true;
 			}
-			if (hcc_ShowUnrefFuncs && d->referenceCount == 0)
+			if (hcc_ShowUnrefFuncs && (d->referenceCount == 0) && globals_done)
 			{ // Function never used
 				printf("unreferenced function '%s'\n", d->name);
 			}
@@ -773,6 +788,8 @@ int main (int argc, char **argv)
 
 	if (CheckParm("-?") || CheckParm("-h") || CheckParm("-help") || CheckParm("--help"))
 	{
+		printf(" -oi              : Optimize Immediates\n");
+		printf(" -on              : Optimize Name Table\n");
 		printf(" -quiet           : Quiet mode\n");
 		printf(" -fileinfo        : Show object sizes per file\n");
 		printf(" -src <directory> : Specify source directory\n");
diff -urNp hcc_old/hcc.h hcc/hcc.h
--- hcc_old/hcc.h	2011-06-02 00:15:46.000000000 +0300
+++ hcc/hcc.h	2011-06-02 00:15:46.000000000 +0300
@@ -17,7 +17,7 @@
 #define MAX_STRINGS		500000
 #define MAX_GLOBALS		16384
 #define MAX_FIELDS		1024
-#define MAX_STATEMENTS		65536
+#define MAX_STATEMENTS		65536*2	// new limit is 2147483647
 #define MAX_FUNCTIONS		8192
 #define MAX_SOUNDS		1024
 #define MAX_MODELS		1024
diff -urNp hcc_old/pr_comp.c hcc/pr_comp.c
--- hcc_old/pr_comp.c	2011-06-03 17:45:22.000000000 +0300
+++ hcc/pr_comp.c	2011-06-03 18:04:23.000000000 +0300
@@ -1248,6 +1248,7 @@ static void ParseFunctionDef (def_t *def
 	if (f->builtin)
 	{
 		df->first_statement = -f->builtin;
+		def->referenceCount++;	
 	}
 	else
 	{
@@ -1337,6 +1338,7 @@ static void ParseCStyleFunctionDef (cons
 		if (f->builtin)
 		{
 			df->first_statement = -f->builtin;
+			def->referenceCount++;
 		}
 		else
 		{
diff -urNp hcc_old/pr_lex.c hcc/pr_lex.c
--- hcc_old/pr_lex.c	2011-06-02 00:15:46.000000000 +0300
+++ hcc/pr_lex.c	2011-06-02 00:15:46.000000000 +0300
@@ -16,7 +16,7 @@
 
 // MACROS ------------------------------------------------------------------
 
-#define MAX_FRAME_DEFS	1024
+#define MAX_FRAME_DEFS	2048
 #define MAX_FRAME_INDEX	256
 #define MAX_BOOKMARKS	26
 
@@ -95,14 +95,14 @@ type_t	type_floatfield	= {ev_field, &def
 
 int	type_size[8]	= { 1, 1, 1, 3, 1, 1, 1, 1 };
 
-def_t	def_void	= {&type_void, "temp"};
-def_t	def_string	= {&type_string, "temp"};
-def_t	def_float	= {&type_float, "temp"};
-def_t	def_vector	= {&type_vector, "temp"};
-def_t	def_entity	= {&type_entity, "temp"};
-def_t	def_field	= {&type_field, "temp"};
-def_t	def_function	= {&type_function, "temp"};
-def_t	def_pointer	= {&type_pointer, "temp"};
+def_t	def_void	= {&type_void, "tmp"};
+def_t	def_string	= {&type_string, "tmp"};
+def_t	def_float	= {&type_float, "tmp"};
+def_t	def_vector	= {&type_vector, "tmp"};
+def_t	def_entity	= {&type_entity, "tmp"};
+def_t	def_field	= {&type_field, "tmp"};
+def_t	def_function	= {&type_function, "tmp"};
+def_t	def_pointer	= {&type_pointer, "tmp"};
 
 def_t	def_ret, def_parms[MAX_PARMS];
 
