these are the differences between the old (from Raven's h2_utils package)
and new versions (from Raven's h2mputil package) of the hcc tool.

diff -urNp hcc.old/expr.c hcc/expr.c
--- hcc.old/expr.c
+++ hcc/expr.c
@@ -297,6 +297,11 @@ static def_t *Term (void)
 	name = PR_ParseName();
 	if ((d = ParseIntrinsicFunc(name)) != NULL)
 	{ // Found and parsed an intrinsic function
+		d->referenceCount++;
+		if (d->parentVector != NULL)
+		{
+			d->parentVector->referenceCount++;
+		}
 		return d;
 	}
 
@@ -376,6 +381,12 @@ static def_t *ParseFunctionCall (def_t *
 		PR_ParseError("not a function");
 	}
 
+	func->referenceCount++;
+	if (func->parentVector != NULL)
+	{
+		func->parentVector->referenceCount++;
+	}
+
 	argCount = 0;
 	args[0] = NULL;
 	args[1] = NULL;
@@ -530,6 +541,30 @@ static void PrecacheModel (def_t *e, int
 // PrecacheFile
 //
 //==========================================================================
+static void PrecacheFileName (const char *n, int ch)
+{
+	int		i;
+
+	for (i = 0; i < numfiles; i++)
+	{
+		if (!strcmp(n, precache_files[i]))
+			return;
+	}
+	if (numfiles == MAX_FILES)
+	{
+		COM_Error("%s: numfiles == MAX_FILES", __thisfunc__);
+	}
+	strcpy(precache_files[i], n);
+	if (ch >= '1' && ch <= '9')
+	{
+		precache_files_block[i] = ch - '0';
+	}
+	else
+	{
+		precache_files_block[i] = 1;
+	}
+	numfiles++;
+}
 
 static void PrecacheFile (def_t *e, int ch)
 {
@@ -640,6 +675,28 @@ static def_t *ParseIntrinsicFunc (const 
 		return &def_ret;
 	}
 
+	if (!strncmp(name, "precache_file", 13))	//keep it from going in progs.dat
+	{
+		def_ret.type = &type_void;
+		LX_Require("(");
+		if (TK_CHECK(TK_RPAREN))
+			return &def_ret;	//it's empty for some reason.
+		//i should be getting an immediate string here
+		if (pr_token_type != tt_immediate)	//oops
+			return NULL;
+		/*
+		expr1 = CO_ParseImmediate();
+		if (expr1->type->type != ev_string)
+			PR_ParseError("'precache_file' : parm not a string");
+		*/
+		if (pr_immediate_type != &type_string)
+			PR_ParseError("'precache_file' : parm not a string");
+		PrecacheFileName(pr_immediate_string, name[13]);
+		LX_Fetch();
+		LX_Require(")");
+
+		return &def_ret;
+	}
 
 	return NULL;
 }
diff -urNp hcc.old/hcc.c hcc/hcc.c
--- hcc.old/hcc.c
+++ hcc/hcc.c
@@ -238,7 +238,7 @@ static void WriteData (int crc)
 	int	i, localName;
 
 	if (hcc_OptimizeNameTable)
-		localName = CopyString("LOCAL+");
+		localName = CopyString("LCL+");
 	else	localName = 0;	/* silence compiler warning */
 
 	for (def = pr.def_head.next; def; def = def->next)
@@ -259,9 +259,12 @@ static void WriteData (int crc)
 		    def->type->type != ev_field &&
 		    def->scope == NULL)
 		{
-			dd->type |= DEF_SAVEGLOBAL;
+			//str_ is a special case string constant
+			if (strncmp (def->name,"STR_", 4) != 0)
+				dd->type |= DEF_SAVEGLOBAL;
 		}
-		if (hcc_OptimizeNameTable && def->scope != NULL)
+		if (hcc_OptimizeNameTable && ((def->scope != NULL) ||
+			(!(dd->type&DEF_SAVEGLOBAL)&&(def->type->type < ev_field))))
 		{
 			dd->s_name = localName;
 		}
@@ -552,6 +555,14 @@ static void PR_PrintStatement (dstatemen
 		printf ("%s", PR_GlobalString(s->a));
 		printf ("%s", PR_GlobalStringNoContents(s->b));
 	}
+	else if ((unsigned int)(s->op - OP_SWITCH_F) < 5)
+	{
+		printf ("%sbranch %i", PR_GlobalString(s->a),s->b);
+	}
+	else if (s->op == OP_CASE)
+	{
+		printf ("of %i branch %i",s->a, s->b);
+	}
 	else
 	{
 		if (s->a)
@@ -600,11 +611,14 @@ Returns false if errors were detected.
 static qboolean FinishCompilation (void)
 {
 	def_t		*d;
-	qboolean	errors;
+	qboolean	errors, globals_done;
 
+	globals_done = false;
 	errors = false;
 	for (d = pr.def_head.next; d; d = d->next)
 	{
+		if (!strcmp (d->name, "end_sys_globals"))
+			globals_done = true;
 		if (d->type->type == ev_function && !d->scope)
 		{
 			if (!d->initialized)
@@ -612,7 +626,7 @@ static qboolean FinishCompilation (void)
 				printf("function '%s' was not defined\n", d->name);
 				errors = true;
 			}
-			if (hcc_ShowUnrefFuncs && d->referenceCount == 0)
+			if (hcc_ShowUnrefFuncs && d->referenceCount == 0 && globals_done)
 			{ // Function never used
 				printf("unreferenced function '%s'\n", d->name);
 			}
@@ -809,6 +823,8 @@ int main (int argc, char **argv)
 
 	if (CheckParm("-?") || CheckParm("-h") || CheckParm("-help") || CheckParm("--help"))
 	{
+		printf(" -oi              : Optimize Immediates\n");
+		printf(" -on              : Optimize Name Table\n");
 		printf(" -quiet           : Quiet mode\n");
 		printf(" -fileinfo        : Show object sizes per file\n");
 		printf(" -src <directory> : Specify source directory\n");
diff -urNp hcc.old/hcc.h hcc/hcc.h
--- hcc.old/hcc.h
+++ hcc/hcc.h
@@ -34,7 +34,7 @@
 #define MAX_STRINGS		500000
 #define MAX_GLOBALS		16384
 #define MAX_FIELDS		1024
-#define MAX_STATEMENTS		65536
+#define MAX_STATEMENTS		65536*2
 #define MAX_FUNCTIONS		8192
 #define MAX_SOUNDS		1024
 #define MAX_MODELS		1024
diff -urNp hcc.old/pr_comp.c hcc/pr_comp.c
--- hcc.old/pr_comp.c
+++ hcc/pr_comp.c
@@ -1262,6 +1262,7 @@ static void ParseFunctionDef (def_t *def
 	if (f->builtin)
 	{
 		df->first_statement = -f->builtin;
+		def->referenceCount++;
 	}
 	else
 	{
@@ -1351,6 +1352,7 @@ static void ParseCStyleFunctionDef (cons
 		if (f->builtin)
 		{
 			df->first_statement = -f->builtin;
+			def->referenceCount++;
 		}
 		else
 		{
diff -urNp hcc.old/pr_lex.c hcc/pr_lex.c
--- hcc.old/pr_lex.c
+++ hcc/pr_lex.c
@@ -34,7 +34,7 @@
 
 // MACROS ------------------------------------------------------------------
 
-#define MAX_FRAME_DEFS	1024
+#define MAX_FRAME_DEFS	2048
 #define MAX_FRAME_INDEX	256
 #define MAX_BOOKMARKS	26
 
@@ -113,14 +113,14 @@ type_t	type_floatfield	= {ev_field, &def
 
 int	type_size[8]	= { 1, 1, 1, 3, 1, 1, 1, 1 };
 
-def_t	def_void	= {&type_void, "temp"};
-def_t	def_string	= {&type_string, "temp"};
-def_t	def_float	= {&type_float, "temp"};
-def_t	def_vector	= {&type_vector, "temp"};
-def_t	def_entity	= {&type_entity, "temp"};
-def_t	def_field	= {&type_field, "temp"};
-def_t	def_function	= {&type_function, "temp"};
-def_t	def_pointer	= {&type_pointer, "temp"};
+def_t	def_void	= {&type_void, "tmp"};
+def_t	def_string	= {&type_string, "tmp"};
+def_t	def_float	= {&type_float, "tmp"};
+def_t	def_vector	= {&type_vector, "tmp"};
+def_t	def_entity	= {&type_entity, "tmp"};
+def_t	def_field	= {&type_field, "tmp"};
+def_t	def_function	= {&type_function, "tmp"};
+def_t	def_pointer	= {&type_pointer, "tmp"};
 
 def_t	def_ret, def_parms[MAX_PARMS];
 
