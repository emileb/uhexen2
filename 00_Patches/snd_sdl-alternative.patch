Alternative sdl audio driver (sdlaudio updates):

Copied QuakeForge bits. Sampling rates 44100 and
48000 are OK, 22050 seems good enough, but 11025
has a noticable latency.

New 2005-07-07: Allocate the buffer on the hunk
New 2006-01-12: Merged quake3 bits to cure most
		of the latency issues
New 2006-09-27: Re-diff'ed after the latest changes

diff -urNp hexen2source-1.4.1/hexen2/snd_sdl.c hexen2source-1.4.1x/hexen2/snd_sdl.c
--- hexen2source-1.4.1/hexen2/snd_sdl.c	2006-09-27 19:08:13.000000000 +0300
+++ hexen2source-1.4.1x/hexen2/snd_sdl.c	2006-09-27 20:02:00.000000000 +0300
@@ -10,21 +10,56 @@
 #include "sdl_inc.h"
 #include "quakedef.h"
 
+static int buffersize;
+static int allocMark = 0;
+
+extern int soundtime;
 
 static void paint_audio(void *unused, Uint8 *stream, int len)
 {
+	int pos, tobufend;
+	int len1, len2;
+
 	if ( !shm )
+	{	// shouldn't happen, but just in case...
+		memset(stream, '\0', len);
 		return;
+	}
+
+	pos = (shm->samplepos * (shm->samplebits/8));
+	if (pos >= buffersize)
+		shm->samplepos = pos = 0;
+
+	tobufend = buffersize - pos;  /* bytes to buffer's end. */
+	len1 = len;
+	len2 = 0;
+
+	if (len1 > tobufend)
+	{
+		len1 = tobufend;
+		len2 = len - len1;
+	}
+
+	memcpy(stream, shm->buffer + pos, len1);
 
-	shm->buffer = stream;
-	shm->samplepos += len/(shm->samplebits/8)/2;
-	// Check for samplepos overflow?
-	S_PaintChannels (shm->samplepos);
+	if (len2 <= 0)
+	{
+		shm->samplepos += (len1 / (shm->samplebits/8));
+	}
+	else
+	{	// wraparound?
+		memcpy(stream+len1, shm->buffer, len2);
+		shm->samplepos = (len2 / (shm->samplebits/8));
+	}
+
+	if (shm->samplepos >= buffersize)
+		shm->samplepos = 0;
 }
 
 qboolean S_SDL_Init(void)
 {
 	SDL_AudioSpec desired, obtained;
+	int		tmp, val;
 	char	drivername[128];
 
 	if (SDL_InitSubSystem (SDL_INIT_AUDIO) < 0)
@@ -37,7 +72,14 @@ qboolean S_SDL_Init(void)
 	desired.freq = desired_speed;
 	desired.format = (desired_bits == 16) ? AUDIO_S16SYS : AUDIO_U8;
 	desired.channels = desired_channels;
-	desired.samples  = 1024; // previously 512 S.A.
+	if (desired.freq <= 11025)
+		desired.samples = 256;
+	else if (desired.freq <= 22050)
+		desired.samples = 512;
+	else if (desired.freq <= 44100)
+		desired.samples = 1024;
+	else
+		desired.samples = 2048;	// (*shrug*)
 	desired.callback = paint_audio;
 	desired.userdata = NULL;
 
@@ -63,6 +105,8 @@ qboolean S_SDL_Init(void)
 		return 0;
 	}
 
+	SDL_LockAudio();
+
 	memset ((dma_t *) &sn, 0, sizeof(sn));
 	shm = &sn;
 
@@ -73,15 +117,27 @@ qboolean S_SDL_Init(void)
 		Con_Printf ("Warning: Rate set (%d) didn't match requested rate (%d)!\n", obtained.freq, desired_speed);
 	shm->speed = obtained.freq;
 	shm->channels = obtained.channels;
-	shm->samples = obtained.samples*shm->channels;
+	tmp = (obtained.samples * obtained.channels) * 10;
+	if (tmp & (tmp - 1))
+	{	// not a power of two? seems to confuse something.
+		val = 1;
+		while (val < tmp)
+			val <<= 1;
+
+		tmp = val;
+	}
+	shm->samples = tmp;
 	shm->samplepos = 0;
 	shm->submission_chunk = 1;
 
-	shm->buffer = NULL;
+	buffersize = shm->samples * (shm->samplebits / 8);
+	allocMark = Hunk_LowMark();
+	shm->buffer = Hunk_AllocName(buffersize, "sdl_audio");
 
 	if (SDL_AudioDriverName(drivername, sizeof (drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
 
+	SDL_UnlockAudio();
 	SDL_PauseAudio(0);
 
 	Con_Printf("Audio Subsystem initialized in SDL mode.\n");
@@ -93,7 +149,9 @@ qboolean S_SDL_Init(void)
 	Con_Printf ("%5d submission_chunk\n", shm->submission_chunk);
 	Con_Printf ("%5d speed\n", shm->speed);
 	Con_Printf ("0x%x dma buffer address\n", (int) shm->buffer);
+	Con_Printf ("%5d buffer size\n", buffersize);
 	Con_Printf ("%5d total_channels\n", total_channels);
+
 	return 1;
 }
 
@@ -107,8 +165,14 @@ void S_SDL_Shutdown(void)
 	if (shm)
 	{
 		Con_Printf ("Shutting down SDL sound\n");
-//		SDL_PauseAudio (1);
+		SDL_PauseAudio(1);
+		SDL_LockAudio();
 		SDL_CloseAudio();
+		if (allocMark)
+		{
+			Hunk_FreeToLowMark(allocMark);
+			allocMark = 0;
+		}
 		SDL_QuitSubSystem(SDL_INIT_AUDIO);
 		shm = NULL;
 	}
diff -urNp hexen2source-1.4.1/hexen2/snd_sys.h hexen2source-1.4.1x/hexen2/snd_sys.h
--- hexen2source-1.4.1/hexen2/snd_sys.h	2006-09-27 19:41:29.000000000 +0300
+++ hexen2source-1.4.1x/hexen2/snd_sys.h	2006-09-27 20:02:00.000000000 +0300
@@ -40,7 +40,7 @@
 
 // this prevents running S_Update_() with the sdl sound driver
 // if the snd_sdl implementation already calls S_PaintChannels.
-#define SDLSOUND_PAINTS_CHANNELS	1
+#define SDLSOUND_PAINTS_CHANNELS	0
 
 #if defined(_WIN32)
 // for the windows crap used in snd_dma.c
diff -urNp hexen2source-1.4.1/hexenworld/Client/snd_sdl.c hexen2source-1.4.1x/hexenworld/Client/snd_sdl.c
--- hexen2source-1.4.1/hexenworld/Client/snd_sdl.c	2006-09-27 19:47:48.000000000 +0300
+++ hexen2source-1.4.1x/hexenworld/Client/snd_sdl.c	2006-09-27 20:02:00.000000000 +0300
@@ -10,21 +10,56 @@
 #include "sdl_inc.h"
 #include "quakedef.h"
 
+static int buffersize;
+static int allocMark = 0;
+
+extern int soundtime;
 
 static void paint_audio(void *unused, Uint8 *stream, int len)
 {
+	int pos, tobufend;
+	int len1, len2;
+
 	if ( !shm )
+	{	// shouldn't happen, but just in case...
+		memset(stream, '\0', len);
 		return;
+	}
+
+	pos = (shm->samplepos * (shm->samplebits/8));
+	if (pos >= buffersize)
+		shm->samplepos = pos = 0;
+
+	tobufend = buffersize - pos;  /* bytes to buffer's end. */
+	len1 = len;
+	len2 = 0;
+
+	if (len1 > tobufend)
+	{
+		len1 = tobufend;
+		len2 = len - len1;
+	}
+
+	memcpy(stream, shm->buffer + pos, len1);
 
-	shm->buffer = stream;
-	shm->samplepos += len/(shm->samplebits/8)/2;
-	// Check for samplepos overflow?
-	S_PaintChannels (shm->samplepos);
+	if (len2 <= 0)
+	{
+		shm->samplepos += (len1 / (shm->samplebits/8));
+	}
+	else
+	{	// wraparound?
+		memcpy(stream+len1, shm->buffer, len2);
+		shm->samplepos = (len2 / (shm->samplebits/8));
+	}
+
+	if (shm->samplepos >= buffersize)
+		shm->samplepos = 0;
 }
 
 qboolean S_SDL_Init(void)
 {
 	SDL_AudioSpec desired, obtained;
+	int		tmp, val;
 	char	drivername[128];
 
 	if (SDL_InitSubSystem (SDL_INIT_AUDIO) < 0)
@@ -37,7 +72,14 @@ qboolean S_SDL_Init(void)
 	desired.freq = desired_speed;
 	desired.format = (desired_bits == 16) ? AUDIO_S16SYS : AUDIO_U8;
 	desired.channels = desired_channels;
-	desired.samples  = 1024; // previously 512 S.A.
+	if (desired.freq <= 11025)
+		desired.samples = 256;
+	else if (desired.freq <= 22050)
+		desired.samples = 512;
+	else if (desired.freq <= 44100)
+		desired.samples = 1024;
+	else
+		desired.samples = 2048;	// (*shrug*)
 	desired.callback = paint_audio;
 	desired.userdata = NULL;
 
@@ -63,6 +105,8 @@ qboolean S_SDL_Init(void)
 		return 0;
 	}
 
+	SDL_LockAudio();
+
 	memset ((dma_t *) &sn, 0, sizeof(sn));
 	shm = &sn;
 
@@ -73,15 +117,27 @@ qboolean S_SDL_Init(void)
 		Con_Printf ("Warning: Rate set (%d) didn't match requested rate (%d)!\n", obtained.freq, desired_speed);
 	shm->speed = obtained.freq;
 	shm->channels = obtained.channels;
-	shm->samples = obtained.samples*shm->channels;
+	tmp = (obtained.samples * obtained.channels) * 10;
+	if (tmp & (tmp - 1))
+	{	// not a power of two? seems to confuse something.
+		val = 1;
+		while (val < tmp)
+			val <<= 1;
+
+		tmp = val;
+	}
+	shm->samples = tmp;
 	shm->samplepos = 0;
 	shm->submission_chunk = 1;
 
-	shm->buffer = NULL;
+	buffersize = shm->samples * (shm->samplebits / 8);
+	allocMark = Hunk_LowMark();
+	shm->buffer = Hunk_AllocName(buffersize, "sdl_audio");
 
 	if (SDL_AudioDriverName(drivername, sizeof (drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
 
+	SDL_UnlockAudio();
 	SDL_PauseAudio(0);
 
 	Con_Printf("Audio Subsystem initialized in SDL mode.\n");
@@ -93,7 +149,9 @@ qboolean S_SDL_Init(void)
 	Con_Printf ("%5d submission_chunk\n", shm->submission_chunk);
 	Con_Printf ("%5d speed\n", shm->speed);
 	Con_Printf ("0x%x dma buffer address\n", (int) shm->buffer);
+	Con_Printf ("%5d buffer size\n", buffersize);
 	Con_Printf ("%5d total_channels\n", total_channels);
+
 	return 1;
 }
 
@@ -107,8 +165,14 @@ void S_SDL_Shutdown(void)
 	if (shm)
 	{
 		Con_Printf ("Shutting down SDL sound\n");
-//		SDL_PauseAudio (1);
+		SDL_PauseAudio(1);
+		SDL_LockAudio();
 		SDL_CloseAudio();
+		if (allocMark)
+		{
+			Hunk_FreeToLowMark(allocMark);
+			allocMark = 0;
+		}
 		SDL_QuitSubSystem(SDL_INIT_AUDIO);
 		shm = NULL;
 	}
diff -urNp hexen2source-1.4.1/hexenworld/Client/snd_sys.h hexen2source-1.4.1x/hexenworld/Client/snd_sys.h
--- hexen2source-1.4.1/hexenworld/Client/snd_sys.h	2006-09-27 19:47:48.000000000 +0300
+++ hexen2source-1.4.1x/hexenworld/Client/snd_sys.h	2006-09-27 20:02:00.000000000 +0300
@@ -40,7 +40,7 @@
 
 // this prevents running S_Update_() with the sdl sound driver
 // if the snd_sdl implementation already calls S_PaintChannels.
-#define SDLSOUND_PAINTS_CHANNELS	1
+#define SDLSOUND_PAINTS_CHANNELS	0
 
 #if defined(_WIN32)
 // for the windows crap used in snd_dma.c

