Alternative sdl audio driver (sdlaudio updates):

Copied QuakeForge bits. Sampling rates 44100 and
48000 are OK, 22050 seems good enough, but 11025
has a noticable latency.

New 2005-07-07: Allocate the buffer on the hunk
New 2006-01-12: Merged quake3 bits to cure most
		of the latency issues
New 2006-09-27: Re-diff'ed after the latest changes
New 2006-10-14: Made buffer allocation method a
		compile-time option: Either allocate
		on the hunk, or use system memory.
		System memory is default. Changed the
		samples multiplier from 10 to 8 .
New 2007-09-15: Adjusted according to the latest
		engine changes.


diff -urNp uhexen2-20070915/hexen2/snd_sdl.c uhexen2-20070915x/hexen2/snd_sdl.c
--- uhexen2-20070915/hexen2/snd_sdl.c	2007-09-15 14:10:03.000000000 +0300
+++ uhexen2-20070915x/hexen2/snd_sdl.c	2007-09-15 16:33:19.000000000 +0300
@@ -16,20 +16,58 @@
 
 #include "sdl_inc.h"
 
+// whether to use hunk for allocating dma
+// buffer memory. either 1, or 0.
+#define USE_HUNK_ALLOC		0
+
+static int	buffersize;
+
+
 static void paint_audio (void *unused, Uint8 *stream, int len)
 {
+	int	pos, tobufend;
+	int	len1, len2;
+
 	if (!shm)
+	{	/* shouldn't happen, but just in case */
+		memset(stream, 0, len);
 		return;
+	}
+
+	pos = (shm->samplepos * (shm->samplebits/8));
+	if (pos >= buffersize)
+		shm->samplepos = pos = 0;
+
+	tobufend = buffersize - pos;  /* bytes to buffer's end. */
+	len1 = len;
+	len2 = 0;
 
-	shm->buffer = stream;
-	shm->samplepos += len / (shm->samplebits/8) / 2;
-	/* check for samplepos overflow? */
-	S_PaintChannels (shm->samplepos);
+	if (len1 > tobufend)
+	{
+		len1 = tobufend;
+		len2 = len - len1;
+	}
+
+	memcpy(stream, shm->buffer + pos, len1);
+
+	if (len2 <= 0)
+	{
+		shm->samplepos += (len1 / (shm->samplebits/8));
+	}
+	else
+	{	/* wraparound? */
+		memcpy(stream+len1, shm->buffer, len2);
+		shm->samplepos = (len2 / (shm->samplebits/8));
+	}
+
+	if (shm->samplepos >= buffersize)
+		shm->samplepos = 0;
 }
 
 qboolean S_SDL_Init (void)
 {
 	SDL_AudioSpec desired, obtained;
+	int		tmp, val;
 	char	drivername[128];
 
 	if (SDL_InitSubSystem(SDL_INIT_AUDIO) < 0)
@@ -42,7 +80,14 @@ qboolean S_SDL_Init (void)
 	desired.freq = desired_speed;
 	desired.format = (desired_bits == 16) ? AUDIO_S16SYS : AUDIO_U8;
 	desired.channels = desired_channels;
-	desired.samples  = 1024; /* previously 512 S.A. */
+	if (desired.freq <= 11025)
+		desired.samples = 256;
+	else if (desired.freq <= 22050)
+		desired.samples = 512;
+	else if (desired.freq <= 44100)
+		desired.samples = 1024;
+	else
+		desired.samples = 2048;	/* shrug */
 	desired.callback = paint_audio;
 	desired.userdata = NULL;
 
@@ -68,7 +113,8 @@ qboolean S_SDL_Init (void)
 		return false;
 	}
 
-	snd_skippaint = true;	/* our callback already 'paints' audio */
+	SDL_LockAudio();
+
 	memset ((void *) &sn, 0, sizeof(sn));
 	shm = &sn;
 
@@ -78,18 +124,41 @@ qboolean S_SDL_Init (void)
 		Con_Printf ("Warning: Rate set (%d) didn't match requested rate (%d)!\n", obtained.freq, desired_speed);
 	shm->speed = obtained.freq;
 	shm->channels = obtained.channels;
-	shm->samples = obtained.samples * shm->channels;
+	tmp = (obtained.samples * obtained.channels) * 8;
+	if (tmp & (tmp - 1))
+	{	/* make it a power of two */
+		val = 1;
+		while (val < tmp)
+			val <<= 1;
+
+		tmp = val;
+	}
+	shm->samples = tmp;
 	shm->samplepos = 0;
 	shm->submission_chunk = 1;
 
-	shm->buffer = NULL;
+	buffersize = shm->samples * (shm->samplebits / 8);
+#if USE_HUNK_ALLOC
+	shm->buffer = Hunk_AllocName(buffersize, "sdl_audio");
+#else
+	shm->buffer = calloc (1, buffersize);
+	if (!shm->buffer)
+	{
+		SDL_CloseAudio();
+		SDL_QuitSubSystem(SDL_INIT_AUDIO);
+		shm = NULL;
+		Con_Printf ("Failed allocating memory for SDL audio\n");
+		return false;
+	}
+#endif
 
 	if (SDL_AudioDriverName(drivername, sizeof(drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
 
+	SDL_UnlockAudio();
 	SDL_PauseAudio(0);
 
-	Con_Printf ("SDL audio driver: %s\n", drivername);
+	Con_Printf ("SDL audio driver: %s, buffer size: %d\n", drivername, buffersize);
 
 	return true;
 }
@@ -104,12 +173,16 @@ void S_SDL_Shutdown (void)
 	if (shm)
 	{
 		Con_Printf ("Shutting down SDL sound\n");
-//		SDL_PauseAudio(1);
+		SDL_PauseAudio(1);
+		SDL_LockAudio ();
 		SDL_CloseAudio();
+#if !USE_HUNK_ALLOC
+		if (shm->buffer)
+			free (shm->buffer);
+#endif
 		SDL_QuitSubSystem(SDL_INIT_AUDIO);
 		shm->buffer = NULL;
 		shm = NULL;
-		snd_skippaint = false;
 	}
 }
 
diff -urNp uhexen2-20070915/hexenworld/Client/snd_sdl.c uhexen2-20070915x/hexenworld/Client/snd_sdl.c
--- uhexen2-20070915/hexenworld/Client/snd_sdl.c	2007-09-15 14:10:03.000000000 +0300
+++ uhexen2-20070915x/hexenworld/Client/snd_sdl.c	2007-09-15 16:33:31.000000000 +0300
@@ -16,20 +16,58 @@
 
 #include "sdl_inc.h"
 
+// whether to use hunk for allocating dma
+// buffer memory. either 1, or 0.
+#define USE_HUNK_ALLOC		0
+
+static int	buffersize;
+
+
 static void paint_audio (void *unused, Uint8 *stream, int len)
 {
+	int	pos, tobufend;
+	int	len1, len2;
+
 	if (!shm)
+	{	/* shouldn't happen, but just in case */
+		memset(stream, 0, len);
 		return;
+	}
+
+	pos = (shm->samplepos * (shm->samplebits/8));
+	if (pos >= buffersize)
+		shm->samplepos = pos = 0;
+
+	tobufend = buffersize - pos;  /* bytes to buffer's end. */
+	len1 = len;
+	len2 = 0;
 
-	shm->buffer = stream;
-	shm->samplepos += len / (shm->samplebits/8) / 2;
-	/* check for samplepos overflow? */
-	S_PaintChannels (shm->samplepos);
+	if (len1 > tobufend)
+	{
+		len1 = tobufend;
+		len2 = len - len1;
+	}
+
+	memcpy(stream, shm->buffer + pos, len1);
+
+	if (len2 <= 0)
+	{
+		shm->samplepos += (len1 / (shm->samplebits/8));
+	}
+	else
+	{	/* wraparound? */
+		memcpy(stream+len1, shm->buffer, len2);
+		shm->samplepos = (len2 / (shm->samplebits/8));
+	}
+
+	if (shm->samplepos >= buffersize)
+		shm->samplepos = 0;
 }
 
 qboolean S_SDL_Init (void)
 {
 	SDL_AudioSpec desired, obtained;
+	int		tmp, val;
 	char	drivername[128];
 
 	if (SDL_InitSubSystem(SDL_INIT_AUDIO) < 0)
@@ -42,7 +80,14 @@ qboolean S_SDL_Init (void)
 	desired.freq = desired_speed;
 	desired.format = (desired_bits == 16) ? AUDIO_S16SYS : AUDIO_U8;
 	desired.channels = desired_channels;
-	desired.samples  = 1024; /* previously 512 S.A. */
+	if (desired.freq <= 11025)
+		desired.samples = 256;
+	else if (desired.freq <= 22050)
+		desired.samples = 512;
+	else if (desired.freq <= 44100)
+		desired.samples = 1024;
+	else
+		desired.samples = 2048;	/* shrug */
 	desired.callback = paint_audio;
 	desired.userdata = NULL;
 
@@ -68,7 +113,8 @@ qboolean S_SDL_Init (void)
 		return false;
 	}
 
-	snd_skippaint = true;	/* our callback already 'paints' audio */
+	SDL_LockAudio();
+
 	memset ((void *) &sn, 0, sizeof(sn));
 	shm = &sn;
 
@@ -78,18 +124,41 @@ qboolean S_SDL_Init (void)
 		Con_Printf ("Warning: Rate set (%d) didn't match requested rate (%d)!\n", obtained.freq, desired_speed);
 	shm->speed = obtained.freq;
 	shm->channels = obtained.channels;
-	shm->samples = obtained.samples * shm->channels;
+	tmp = (obtained.samples * obtained.channels) * 8;
+	if (tmp & (tmp - 1))
+	{	/* make it a power of two */
+		val = 1;
+		while (val < tmp)
+			val <<= 1;
+
+		tmp = val;
+	}
+	shm->samples = tmp;
 	shm->samplepos = 0;
 	shm->submission_chunk = 1;
 
-	shm->buffer = NULL;
+	buffersize = shm->samples * (shm->samplebits / 8);
+#if USE_HUNK_ALLOC
+	shm->buffer = Hunk_AllocName(buffersize, "sdl_audio");
+#else
+	shm->buffer = calloc (1, buffersize);
+	if (!shm->buffer)
+	{
+		SDL_CloseAudio();
+		SDL_QuitSubSystem(SDL_INIT_AUDIO);
+		shm = NULL;
+		Con_Printf ("Failed allocating memory for SDL audio\n");
+		return false;
+	}
+#endif
 
 	if (SDL_AudioDriverName(drivername, sizeof(drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
 
+	SDL_UnlockAudio();
 	SDL_PauseAudio(0);
 
-	Con_Printf ("SDL audio driver: %s\n", drivername);
+	Con_Printf ("SDL audio driver: %s, buffer size: %d\n", drivername, buffersize);
 
 	return true;
 }
@@ -104,12 +173,16 @@ void S_SDL_Shutdown (void)
 	if (shm)
 	{
 		Con_Printf ("Shutting down SDL sound\n");
-//		SDL_PauseAudio(1);
+		SDL_PauseAudio(1);
+		SDL_LockAudio ();
 		SDL_CloseAudio();
+#if !USE_HUNK_ALLOC
+		if (shm->buffer)
+			free (shm->buffer);
+#endif
 		SDL_QuitSubSystem(SDL_INIT_AUDIO);
 		shm->buffer = NULL;
 		shm = NULL;
-		snd_skippaint = false;
 	}
 }
 

