Updates to sdl sound:
Copied QuakeForge bits. Sampling rates 44100 and
48000 are just fine, 22050 seems good enough, but
11025 has a noticable latency. 8000 rate is almost
unusable. Mono sound is almost unusable as before.

New 2005-07-07: Allocate the buffer on the hunk
New 2006-01-12: Merged quake3 bits to cure most of the
latency issues, re-diffed after the latest sound changes

diff -urNp hexen2source-1.4.1/hexen2/snd_sdl.c hexen2source-1.4.1x/hexen2/snd_sdl.c
--- hexen2source-1.4.1/hexen2/snd_sdl.c	2006-05-20 15:49:36.000000000 +0300
+++ hexen2source-1.4.1x/hexen2/snd_sdl.c	2006-05-20 15:51:47.000000000 +0300
@@ -10,22 +10,56 @@
 #include "sdl_inc.h"
 #include "quakedef.h"
 
-static int snd_inited;
+static int buffersize, snd_inited;
+static int allocMark = 0;
+
+extern int soundtime;
 
 static void paint_audio(void *unused, Uint8 *stream, int len)
 {
-	if ( !shm )
+	int pos, tobufend;
+	int len1, len2;
+
+	if (!snd_inited)
+	{	// shouldn't happen, but just in case...
+		memset(stream, '\0', len);
 		return;
+	}
+
+	pos = (shm->samplepos * (shm->samplebits/8));
+	if (pos >= buffersize)
+		shm->samplepos = pos = 0;
+
+	tobufend = buffersize - pos;  /* bytes to buffer's end. */
+	len1 = len;
+	len2 = 0;
+
+	if (len1 > tobufend)
+	{
+		len1 = tobufend;
+		len2 = len - len1;
+	}
+
+	memcpy(stream, shm->buffer + pos, len1);
 
-	shm->buffer = stream;
-	shm->samplepos += len/(shm->samplebits/8)/2;
-	// Check for samplepos overflow?
-	S_PaintChannels (shm->samplepos);
+	if (len2 <= 0)
+	{
+		shm->samplepos += (len1 / (shm->samplebits/8));
+	}
+	else
+	{	// wraparound?
+		memcpy(stream+len1, shm->buffer, len2);
+		shm->samplepos = (len2 / (shm->samplebits/8));
+	}
+
+	if (shm->samplepos >= buffersize)
+		shm->samplepos = 0;
 }
 
 qboolean S_SDL_Init(void)
 {
 	SDL_AudioSpec desired, obtained;
+	int		tmp, val;
 	char	drivername[128];
 
 	snd_inited = 0;
@@ -52,7 +86,14 @@ qboolean S_SDL_Init(void)
 	}
 
 	desired.channels = desired_channels;
-	desired.samples  = 1024; // previously 512 S.A.
+	if (desired.freq <= 11025)
+		desired.samples = 256;
+	else if (desired.freq <= 22050)
+		desired.samples = 512;
+	else if (desired.freq <= 44100)
+		desired.samples = 1024;
+	else
+		desired.samples = 2048;	// (*shrug*)
 	desired.callback = paint_audio;
 	desired.userdata = NULL;
 
@@ -90,6 +131,8 @@ qboolean S_SDL_Init(void)
 			break;
 	}
 
+	SDL_LockAudio();
+
 	/* Fill the audio DMA information block */
 	shm = &sn;
 	shm->splitbuffer = 0;
@@ -98,16 +141,28 @@ qboolean S_SDL_Init(void)
 		Con_Printf ("Warning: Rate set (%i) didn't match requested rate (%i)!\n", obtained.freq, desired_speed);
 	shm->speed = obtained.freq;
 	shm->channels = obtained.channels;
-	shm->samples = obtained.samples*shm->channels;
+	tmp = (obtained.samples * obtained.channels) * 10;
+	if (tmp & (tmp - 1))
+	{	// not a power of two? seems to confuse something.
+		val = 1;
+		while (val < tmp)
+			val <<= 1;
+
+		tmp = val;
+	}
+	shm->samples = tmp;
 	shm->samplepos = 0;
 	shm->submission_chunk = 1;
 
-	shm->buffer = NULL;
+	buffersize = shm->samples * (shm->samplebits / 8);
+	allocMark = Hunk_LowMark();
+	shm->buffer = Hunk_AllocName(buffersize, "sdl_audio");
 
 	if (SDL_AudioDriverName(drivername, sizeof (drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
 
 	snd_inited = 1;
+	SDL_UnlockAudio();
 	SDL_PauseAudio(0);
 
 	Con_Printf("Audio Subsystem initialized in SDL mode.\n");
@@ -119,7 +174,9 @@ qboolean S_SDL_Init(void)
 	Con_Printf ("%5d submission_chunk\n", shm->submission_chunk);
 	Con_Printf ("%5d speed\n", shm->speed);
 	Con_Printf ("0x%x dma buffer address\n", (int) shm->buffer);
+	Con_Printf ("%5d buffer size\n", buffersize);
 	Con_Printf ("%5d total_channels\n", total_channels);
+
 	return 1;
 }
 
@@ -134,8 +191,15 @@ void S_SDL_Shutdown(void)
 	{
 		Con_Printf ("Shutting down SDL sound\n");
 		snd_inited = 0;
-//		SDL_PauseAudio (1);
+		SDL_PauseAudio(1);
+		SDL_LockAudio();
 		SDL_CloseAudio();
+		if (allocMark)
+		{
+			Hunk_FreeToLowMark(allocMark);
+			allocMark = 0;
+		}
+		shm = NULL;
 		SDL_QuitSubSystem(SDL_INIT_AUDIO);
 	}
 }
diff -urNp hexen2source-1.4.1/hexen2/snd_sys.h hexen2source-1.4.1x/hexen2/snd_sys.h
--- hexen2source-1.4.1/hexen2/snd_sys.h	2006-05-20 15:49:36.000000000 +0300
+++ hexen2source-1.4.1x/hexen2/snd_sys.h	2006-05-20 15:51:47.000000000 +0300
@@ -20,7 +20,7 @@
 
 // this prevents running S_Update_() with the sdl sound driver
 // if the snd_sdl implementation already calls S_PaintChannels.
-#define SDLSOUND_PAINTS_CHANNELS	1
+#define SDLSOUND_PAINTS_CHANNELS	0
 
 #if defined(_WIN32)
 // for the windows crap used in snd_dma.c
diff -urNp hexen2source-1.4.1/hexenworld/Client/snd_sdl.c hexen2source-1.4.1x/hexenworld/Client/snd_sdl.c
--- hexen2source-1.4.1/hexenworld/Client/snd_sdl.c	2006-05-20 15:49:36.000000000 +0300
+++ hexen2source-1.4.1x/hexenworld/Client/snd_sdl.c	2006-05-20 15:51:47.000000000 +0300
@@ -10,22 +10,56 @@
 #include "sdl_inc.h"
 #include "quakedef.h"
 
-static int snd_inited;
+static int buffersize, snd_inited;
+static int allocMark = 0;
+
+extern int soundtime;
 
 static void paint_audio(void *unused, Uint8 *stream, int len)
 {
-	if ( !shm )
+	int pos, tobufend;
+	int len1, len2;
+
+	if (!snd_inited)
+	{	// shouldn't happen, but just in case...
+		memset(stream, '\0', len);
 		return;
+	}
+
+	pos = (shm->samplepos * (shm->samplebits/8));
+	if (pos >= buffersize)
+		shm->samplepos = pos = 0;
+
+	tobufend = buffersize - pos;  /* bytes to buffer's end. */
+	len1 = len;
+	len2 = 0;
+
+	if (len1 > tobufend)
+	{
+		len1 = tobufend;
+		len2 = len - len1;
+	}
+
+	memcpy(stream, shm->buffer + pos, len1);
 
-	shm->buffer = stream;
-	shm->samplepos += len/(shm->samplebits/8)/2;
-	// Check for samplepos overflow?
-	S_PaintChannels (shm->samplepos);
+	if (len2 <= 0)
+	{
+		shm->samplepos += (len1 / (shm->samplebits/8));
+	}
+	else
+	{	// wraparound?
+		memcpy(stream+len1, shm->buffer, len2);
+		shm->samplepos = (len2 / (shm->samplebits/8));
+	}
+
+	if (shm->samplepos >= buffersize)
+		shm->samplepos = 0;
 }
 
 qboolean S_SDL_Init(void)
 {
 	SDL_AudioSpec desired, obtained;
+	int		tmp, val;
 	char	drivername[128];
 
 	snd_inited = 0;
@@ -52,7 +86,14 @@ qboolean S_SDL_Init(void)
 	}
 
 	desired.channels = desired_channels;
-	desired.samples  = 1024; // previously 512 S.A.
+	if (desired.freq <= 11025)
+		desired.samples = 256;
+	else if (desired.freq <= 22050)
+		desired.samples = 512;
+	else if (desired.freq <= 44100)
+		desired.samples = 1024;
+	else
+		desired.samples = 2048;	// (*shrug*)
 	desired.callback = paint_audio;
 	desired.userdata = NULL;
 
@@ -90,6 +131,8 @@ qboolean S_SDL_Init(void)
 			break;
 	}
 
+	SDL_LockAudio();
+
 	/* Fill the audio DMA information block */
 	shm = &sn;
 	shm->splitbuffer = 0;
@@ -98,16 +141,28 @@ qboolean S_SDL_Init(void)
 		Con_Printf ("Warning: Rate set (%i) didn't match requested rate (%i)!\n", obtained.freq, desired_speed);
 	shm->speed = obtained.freq;
 	shm->channels = obtained.channels;
-	shm->samples = obtained.samples*shm->channels;
+	tmp = (obtained.samples * obtained.channels) * 10;
+	if (tmp & (tmp - 1))
+	{	// not a power of two? seems to confuse something.
+		val = 1;
+		while (val < tmp)
+			val <<= 1;
+
+		tmp = val;
+	}
+	shm->samples = tmp;
 	shm->samplepos = 0;
 	shm->submission_chunk = 1;
 
-	shm->buffer = NULL;
+	buffersize = shm->samples * (shm->samplebits / 8);
+	allocMark = Hunk_LowMark();
+	shm->buffer = Hunk_AllocName(buffersize, "sdl_audio");
 
 	if (SDL_AudioDriverName(drivername, sizeof (drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
 
 	snd_inited = 1;
+	SDL_UnlockAudio();
 	SDL_PauseAudio(0);
 
 	Con_Printf("Audio Subsystem initialized in SDL mode.\n");
@@ -119,7 +174,9 @@ qboolean S_SDL_Init(void)
 	Con_Printf ("%5d submission_chunk\n", shm->submission_chunk);
 	Con_Printf ("%5d speed\n", shm->speed);
 	Con_Printf ("0x%x dma buffer address\n", (int) shm->buffer);
+	Con_Printf ("%5d buffer size\n", buffersize);
 	Con_Printf ("%5d total_channels\n", total_channels);
+
 	return 1;
 }
 
@@ -134,8 +191,15 @@ void S_SDL_Shutdown(void)
 	{
 		Con_Printf ("Shutting down SDL sound\n");
 		snd_inited = 0;
-//		SDL_PauseAudio (1);
+		SDL_PauseAudio(1);
+		SDL_LockAudio();
 		SDL_CloseAudio();
+		if (allocMark)
+		{
+			Hunk_FreeToLowMark(allocMark);
+			allocMark = 0;
+		}
+		shm = NULL;
 		SDL_QuitSubSystem(SDL_INIT_AUDIO);
 	}
 }
diff -urNp hexen2source-1.4.1/hexenworld/Client/snd_sys.h hexen2source-1.4.1x/hexenworld/Client/snd_sys.h
--- hexen2source-1.4.1/hexenworld/Client/snd_sys.h	2006-05-20 15:49:36.000000000 +0300
+++ hexen2source-1.4.1x/hexenworld/Client/snd_sys.h	2006-05-20 15:51:47.000000000 +0300
@@ -20,7 +20,7 @@
 
 // this prevents running S_Update_() with the sdl sound driver
 // if the snd_sdl implementation already calls S_PaintChannels.
-#define SDLSOUND_PAINTS_CHANNELS	1
+#define SDLSOUND_PAINTS_CHANNELS	0
 
 #if defined(_WIN32)
 // for the windows crap used in snd_dma.c

